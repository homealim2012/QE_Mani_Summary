/*! (c) 2016 Pranav Rajpurkar and Stephen Koo, MIT License */
/******/
(function (modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/
    var installedModules = {};

    /******/ 	// The require function
    /******/
    function __webpack_require__(moduleId) {

        /******/ 		// Check if module is in cache
        /******/
        if (installedModules[moduleId])
        /******/            return installedModules[moduleId].exports;

        /******/ 		// Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/            exports: {},
            /******/            id: moduleId,
            /******/            loaded: false
            /******/
        };

        /******/ 		// Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

        /******/ 		// Flag the module as loaded
        /******/
        module.loaded = true;

        /******/ 		// Return the exports of the module
        /******/
        return module.exports;
        /******/
    }


    /******/ 	// expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;

    /******/ 	// expose the module cache
    /******/
    __webpack_require__.c = installedModules;

    /******/ 	// __webpack_public_path__
    /******/
    __webpack_require__.p = "";

    /******/ 	// Load entry module and return exports
    /******/
    return __webpack_require__(0);
    /******/
})
/************************************************************************/
/******/([
    /* 0 */
    /***/ function (module, exports, __webpack_require__) {

        var gaussian = __webpack_require__(1)
        var pool = __webpack_require__(2)
        var ops = __webpack_require__(6)
        var bhtree = __webpack_require__(18)
        var vptree = __webpack_require__(19)
        var tsneez = tsneez || {}

            ;
        (function (global) {
            'use strict'

            var getopt = function (opt, key, def) {
                if (opt[key] == null) {
                    return def
                } else {
                    return opt[key]
                }
            }

            var squaredEuclidean = function (x, y) {
                // Compute Euclidean distance between two vectors as Arrays
                var m = x.length
                var d = 0
                var k, xk, yk
                for (k = 0; k < m; k++) {
                    xk = x[k]
                    yk = y[k]
                    d += (xk - yk) * (xk - yk)
                }
                return d
            }

            var euclideanOf = function (data) {
                return function (x, y) {
                    return Math.sqrt(squaredEuclidean(data[x], data[y]))
                }
            }

            function sign(x) {
                return x > 0 ? 1 : x < 0 ? -1 : 0
            }

            var TSNEEZ = function (opt) {
                var perplexity = getopt(opt, 'perplexity', 30)  // (van der Maaten 2014)
                this.Hdesired = Math.log2(perplexity)
                this.numNeighbors = getopt(opt, 'numNeighbors', 3 * perplexity)  // (van der Maaten 2014)
                this.theta = getopt(opt, 'theta', 0.5)  // [0, 1] tunes the barnes-hut approximation, 0 is exact
                this.learningRate = getopt(opt, 'learningRate', 1)
                this.earlyExaggeration = getopt(opt, 'earlyExaggeration', 10)
                this.randomProjectionInitialize = getopt(opt, 'randomProjectionInitialize', true) // whether to initialize ys with a random projection
                this.exagEndIter = getopt(opt, 'exagEndIter', 250) // (van der Maaten 2014)
                this.dims = getopt(opt, 'dims', 2)
            }

            TSNEEZ.prototype = {
                profileRecord: {},
                profileStart: function (name) {
                    if (!this.profileRecord.hasOwnProperty(name)) {
                        this.profileRecord[name] = {
                            count: 0,
                            time: 0
                        }
                    }
                    this.profileRecord[name].tic = performance.now()
                },
                profileEnd: function (name) {
                    var toc = performance.now()
                    var record = this.profileRecord[name]
                    var elapsed = Math.round(toc - record.tic)
                    record.count++
                    record.time += (elapsed - record.time) / record.count
                    console.log(name + ': ' + elapsed + 'ms' + ', avg ' + Math.round(record.time) + 'ms')
                },
                initYWithRandomProjection: function () {
                    var distribution = gaussian(0, 1 / this.dims)
                    var A = pool.zeros([this.largeDims, this.dims])
                    for (var i = 0; i < A.shape[0]; i++) {
                        for (var j = 0; j < A.shape[1]; j++) {
                            A.set(i, j, distribution.ppf(Math.random()))
                        }
                    }
                    for (var p = 0; p < this.n; p++) {
                        var x = this.X[p]
                        for (var j = 0; j < this.dims; j++) {
                            var sum = 0
                            for (var i = 0; i < this.largeDims; i++) {
                                sum += A.get(i, j) * x[i]
                            }
                            this.Y.set(p, j, sum)
                        }
                    }

                    var means = []
                    var standardDeviations = []

                    for (var j = 0; j < this.dims; j++) {
                        var sum = 0
                        for (var i = 0; i < this.n; i++) {
                            sum += this.Y.get(i, j)
                        }
                        means.push(sum / this.n)
                    }

                    for (var j = 0; j < this.dims; j++) {
                        var sumOfSquareDifference = 0;
                        for (var i = 0; i < this.n; i++) {
                            sumOfSquareDifference += Math.pow(this.Y.get(i, j) - means[j], 2)
                        }
                        standardDeviations.push(Math.sqrt(sumOfSquareDifference / this.n))
                    }

                    for (var j = 0; j < this.dims; j++) {
                        for (var i = 0; i < this.n; i++) {
                            this.Y.set(i, j, (this.Y.get(i, j) - means[j]) / standardDeviations[j])
                        }
                    }
                },
                initYGaussian: function (start) {
                    var distribution = gaussian(0, 1e-4)
                    for (var i = start; i < this.n; i++) {
                        for (var j = 0; j < this.dims; j++) {
                            this.Y.set(i, j, distribution.ppf(Math.random()))
                            this.Y.set(i, j, distribution.ppf(Math.random()))
                        }
                    }
                },
                updateY: function () {
                    // Perform gradient update in place
                    var momentum = 0.9
                    var n = this.n
                    var dims = this.dims
                    var Ymean = pool.zeros([this.dims])
                    var lr = this.learningRate

                    for (var i = 0; i < n; i++) {
                        for (var d = 0; d < dims; d++) {
                            var gradid = this.grad.get(i, d)
                            var stepid = this.ytMinus1.get(i, d) - this.ytMinus2.get(i, d)
                            var gainid = this.Ygains.get(i, d)

                            // Update gain
                            var newgain = Math.max(
                                sign(gradid) === sign(stepid) ? gainid * 0.8 : gainid + 0.2, 0.01)
                            this.Ygains.set(i, d, newgain)

                            // Update Y
                            var Yid = (this.ytMinus1.get(i, d)
                            - lr * newgain * gradid
                            + momentum * stepid)
                            this.Y.set(i, d, Yid)

                            // Accumulate mean for centering
                            Ymean.set(d, Ymean.get(d) + Yid)
                        }
                    }

                    // Recenter
                    for (var i = 0; i < n; i++) {
                        for (var d = 0; d < dims; d++) {
                            this.Y.set(i, d, this.Y.get(i, d) - Ymean.get(d) / n)
                        }
                    }
                },
                updateGradBH: function () {
                    // Early exaggeration
                    var exag = (this.iter <= this.exagEndIter) ? Math.max(this.earlyExaggeration * Math.pow(0.99, this.iter), 1) : 1

                    // Initialize quadtree
                    var bht = bhtree.BarnesHutTree()
                    bht.initWithData(this.Y, this.theta, this.n)

                    // Compute gradient of the KL divergence
                    var n = this.n
                    var dims = this.dims

                    // Compute Frep using Barnes-Hut
                    var Z = 0
                    for (var i = 0; i < n; i++) {
                        // NOTE: 2D only
                        var Frep = bht.computeForces(this.Y.get(i, 0), this.Y.get(i, 1))
                        this.grad.set(i, 0, 4 * Frep.x)
                        this.grad.set(i, 1, 4 * Frep.y)
                        Z += Frep.Z
                    }

                    // Compute Fattr over sparse P
                    var gradi = new Float64Array(dims)
                    for (var i = 0; i < n; i++) {
                        // Reset
                        for (var d = 0; d < dims; d++) gradi[d] = 0

                        // Accumulate Fattr over nearest neighbors
                        var pi = this.P[i]
                        for (var k = 0; k < this.numNeighbors; k++) {
                            var j = this.NN.get(i, k)
                            var Dij = this.D[i][j]

                            // Symmetrize on-demand
                            var Pij = (pi[j] + (this.P[j][i] || 0)) / (2 * this.n)

                            // Unfurled loop, but 2D only
                            var mulFactor = 4 * exag * Pij * (1.0 / (1.0 + Dij))
                            gradi[0] += mulFactor * (this.Y.get(i, 0) - this.Y.get(j, 0))
                            gradi[1] += mulFactor * (this.Y.get(i, 1) - this.Y.get(j, 1))
                        }

                        // Normalize Frep then increment gradient
                        for (var d = 0; d < dims; d++) {
                            this.grad.set(i, d, this.grad.get(i, d) / Z + gradi[d])
                        }
                    }
                },

                XToD: function () {
                    var indices = Array.apply(null, Array(this.n)).map(function (_, i) {
                        return i
                    })
                    this.vpt = vptree.build(indices, euclideanOf(this.X))
                    this.D = []
                    this.dmax = []
                    this.kmax = []
                    for (var i = 0; i < this.n; i++) {
                        this.pushD(i)
                    }
                },

                pushD: function (i) {
                    var neighbors = this.vpt.search(i, this.numNeighbors + 1)
                    neighbors.shift() // first element is own self
                    var elem = {}
                    var dmaxi = 0
                    var kmaxi
                    for (var j = 0; j < neighbors.length; j++) {
                        var neighbor = neighbors[j]
                        elem[neighbor.i] = neighbor.d * neighbor.d
                        this.NN.set(i, j, neighbor.i)

                        // Keep track of maximum distance
                        if (neighbor.d > dmaxi) {
                            dmaxi = neighbor.d
                            kmaxi = neighbor.i
                        }
                    }
                    this.D.push(elem)
                    this.dmax.push(dmaxi)
                    this.kmax.push(kmaxi)
                },

                setPiAndGetH: function (i, beta) {
                    // Compute a single row Pi of the kernel and the Shannon entropy H

                    var pi = {}
                    var sum = 0
                    var Di = this.D[i]
                    for (var k = 0; k < this.numNeighbors; k++) {
                        var key = this.NN.get(i, k)
                        var elem = Math.exp(-beta * Di[key])
                        pi[key] = elem
                        sum += elem
                    }

                    // For debugging
                    // if (sum === 0) {
                    //  console.count('sum equals zero')
                    // }

                    var H = 0
                    for (var k = 0; k < this.numNeighbors; k++) {
                        var key = this.NN.get(i, k)
                        var val = pi[key] / sum
                        pi[key] = val
                        if (val > 1e-7) { // TODO: do we need this?
                            H -= val * Math.log2(val)
                        }
                    }

                    this.P[i] = pi
                    this.Psum[i] = sum
                    return H
                },

                DToP: function () {
                    this.P = []
                    this.Psum = []
                    this.beta = []

                    for (var i = 0; i < this.n; i++) {
                        this.pushP(i)
                    }
                },

                pushP: function (i) {
                    // We perform binary search to find the beta such that
                    // the conditional distribution P_i has the given perplexity.
                    // We define:
                    //   beta = 1 / (2 * sigma_i^2)
                    // where sigma_i is the bandwith of the Gaussian kernel
                    // for the conditional distribution P_i
                    var beta = 1
                    var betamin = -Infinity
                    var betamax = Infinity
                    var Hdiff
                    var numTries = 0

                    do {
                        numTries++
                        var H = this.setPiAndGetH(i, beta)
                        Hdiff = H - this.Hdesired

                        if (Hdiff > 0) {
                            // Entropy too high, beta is too small
                            betamin = beta
                            if (betamax === Infinity) {
                                beta = beta * 2
                            } else {
                                beta = (beta + betamax) / 2
                            }
                        } else {
                            // Entropy is too low, beta is too big
                            betamax = beta
                            if (betamin === -Infinity) {
                                beta = beta / 2
                            } else {
                                beta = (beta + betamin) / 2
                            }
                        }
                    } while (Math.abs(Hdiff) > 1e-05 && numTries < 50)
                    this.beta.push(beta)
                },

                /* Update neighborhoods of other points
                 *
                 * newj - index of the new point
                 */
                updateNeighborhoods: function (newj) {
                    var i, newd, kmax, dmax, jmax, newdSq
                    for (i = 0; i < newj; i++) {
                        dmax = this.dmax[i]
                        newdSq = squaredEuclidean(this.X[newj], this.X[i])
                        newd = Math.sqrt(newdSq)

                        if (newd < dmax) {
                            // Xnewj is in the neighborhood of Xi!
                            // Replace the point farthest away from Xi in neighborhood
                            kmax = this.kmax[i]
                            jmax = this.NN[kmax]
                            this.NN[kmax] = newj
                            delete this.P[i][jmax]  // or this.P[i][jmax] = 0?

                            // Compute approximate update with old beta and Psum
                            // (Note that to compute an exact update, we have to redo the
                            // search for beta, or at least renormalize Pi)
                            this.P[i][newj] = Math.exp(-this.beta[i] * newdSq) / this.Psum[i]
                        }
                    }
                },

                pushY: function (newi) {
                    // Initialize embedding as weighted average of its neighbors (Pezzotti)
                    var Pi = this.P[newi]
                    var y0 = 0
                    var y1 = 0
                    var k, j, Pji
                    for (k = 0; k < this.numNeighbors; k++) {
                        j = this.NN.get(newi, k)
                        Pji = Pi[j]
                        y0 = Pji * this.Y.get(j, 0)
                        y1 = Pji * this.Y.get(j, 1)
                    }
                    this.Y.set(newi, 0, y0)
                    this.Y.set(newi, 1, y1)
                },

                /************************
                 * PUBLIC API STARTS HERE
                 ************************/

                initData: function (X, reinit, oldN) {
                    this.X = X
                    this.n = this.X.length
                    this.largeDims = this.X[0].length

                    if (this.NN) pool.free(this.NN)
                    this.NN = pool.zeros([this.n + 100, this.numNeighbors]) // init w 100 extra spots

                    var Y = pool.zeros([this.n + 100, this.dims])  // init w 100 extra spots
                    var Ygains = pool.ones(Y.shape)
                    var grad = pool.zeros(Y.shape)
                    var that = this
                    if (reinit) {
                        ['Y', 'Ygains', 'grad'].forEach(function (name) {
                            var newMat = eval(name)
                            var oldMat = that[name]
                            ops.assign(newMat.hi(oldMat.shape[0], oldMat.shape[1]), oldMat)
                            pool.free(oldMat)
                        })
                    }
                    this.Y = Y
                    this.Ygains = Ygains
                    this.grad = grad

                    if (reinit) {
                        this.initYGaussian(oldN + 1)
                        this.iter = 0
                    } else {
                        this.initYGaussian(0)
                        this.iter = 0
                    }

                    if (reinit) {
                        pool.free(this.ytMinus1)
                        pool.free(this.ytMinus2)
                    }
                    this.ytMinus1 = pool.clone(this.Y)
                    this.ytMinus2 = pool.clone(this.Y)

                    this.XToD()
                    this.DToP()
                },

                /*
                 * XNew - array containing the new points
                 */
                addPoints: function (XNew) {
                    if (XNew[0].length !== this.X[0].length) {
                        console.log("New points don't match input dimensions")
                        return
                    }

                    var newLength = this.n + XNew.length

                    if (newLength > this.Y.shape[0]) {
                        this.X.push.apply(this.X, XNew)
                        this.initData(this.X, true, XNew.length)
                    } else {
                        this.exagEndIter = Math.max(this.iter, this.exagEndIter) + 200
                        this.X.push.apply(this.X, XNew)
                        // Do approximative updates for each point
                        for (var i = this.n; i < newLength; i++) {
                            this.n++
                            this.updateNeighborhoods(i)
                            this.pushD(i)
                            this.pushP(i)
                            this.pushY(i)
                        }
                    }
                },

                step: function () {
                    // Compute gradient
                    if (this.iter > this.exagEndIter) return

                    this.updateGradBH()

                    // Rotate buffers
                    var temp = this.ytMinus2
                    this.ytMinus2 = this.ytMinus1
                    this.ytMinus1 = this.Y
                    this.Y = temp

                    // Perform update
                    this.updateY()

                    this.iter++
                }
            }

            global.TSNEEZ = TSNEEZ
        })(tsneez)

        // export the library to window, or to module in nodejs
        // Webpack supports both.
        ;
        (function (lib) {
            'use strict'
            if (typeof module !== 'undefined' && typeof module.exports === 'undefined') {
                module.exports = lib // in nodejs
            }
            if (typeof window !== 'undefined') {
                window.tsneez = lib // in ordinary browser attach library to window
            }
        })(tsneez)


        /***/
    },
    /* 1 */
    /***/ function (module, exports, __webpack_require__) {

        (function (exports) {

            // Complementary error function
            // From Numerical Recipes in C 2e p221
            var erfc = function (x) {
                var z = Math.abs(x);
                var t = 1 / (1 + z / 2);
                var r = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 +
                        t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 +
                        t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 +
                        t * (-0.82215223 + t * 0.17087277)))))))))
                return x >= 0 ? r : 2 - r;
            };

            // Inverse complementary error function
            // From Numerical Recipes 3e p265
            var ierfc = function (x) {
                if (x >= 2) {
                    return -100;
                }
                if (x <= 0) {
                    return 100;
                }

                var xx = (x < 1) ? x : 2 - x;
                var t = Math.sqrt(-2 * Math.log(xx / 2));

                var r = -0.70711 * ((2.30753 + t * 0.27061) /
                    (1 + t * (0.99229 + t * 0.04481)) - t);

                for (var j = 0; j < 2; j++) {
                    var err = erfc(r) - xx;
                    r += err / (1.12837916709551257 * Math.exp(-(r * r)) - r * err);
                }

                return (x < 1) ? r : -r;
            };

            // Models the normal distribution
            var Gaussian = function (mean, variance) {
                if (variance <= 0) {
                    throw new Error('Variance must be > 0 (but was ' + variance + ')');
                }
                this.mean = mean;
                this.variance = variance;
                this.standardDeviation = Math.sqrt(variance);
            }

            // Probability density function
            Gaussian.prototype.pdf = function (x) {
                var m = this.standardDeviation * Math.sqrt(2 * Math.PI);
                var e = Math.exp(-Math.pow(x - this.mean, 2) / (2 * this.variance));
                return e / m;
            };

            // Cumulative density function
            Gaussian.prototype.cdf = function (x) {
                return 0.5 * erfc(-(x - this.mean) / (this.standardDeviation * Math.sqrt(2)));
            };

            // Percent point function
            Gaussian.prototype.ppf = function (x) {
                return this.mean - this.standardDeviation * Math.sqrt(2) * ierfc(2 * x);
            };

            // Product distribution of this and d (scale for constant)
            Gaussian.prototype.mul = function (d) {
                if (typeof(d) === "number") {
                    return this.scale(d);
                }
                var precision = 1 / this.variance;
                var dprecision = 1 / d.variance;
                return fromPrecisionMean(
                    precision + dprecision,
                    precision * this.mean + dprecision * d.mean);
            };

            // Quotient distribution of this and d (scale for constant)
            Gaussian.prototype.div = function (d) {
                if (typeof(d) === "number") {
                    return this.scale(1 / d);
                }
                var precision = 1 / this.variance;
                var dprecision = 1 / d.variance;
                return fromPrecisionMean(
                    precision - dprecision,
                    precision * this.mean - dprecision * d.mean);
            };

            // Addition of this and d
            Gaussian.prototype.add = function (d) {
                return gaussian(this.mean + d.mean, this.variance + d.variance);
            };

            // Subtraction of this and d
            Gaussian.prototype.sub = function (d) {
                return gaussian(this.mean - d.mean, this.variance + d.variance);
            };

            // Scale this by constant c
            Gaussian.prototype.scale = function (c) {
                return gaussian(this.mean * c, this.variance * c * c);
            };

            var gaussian = function (mean, variance) {
                return new Gaussian(mean, variance);
            };

            var fromPrecisionMean = function (precision, precisionmean) {
                return gaussian(precisionmean / precision, 1 / precision);
            };

            exports(gaussian);
        })
        (true
            ? function (e) {
            module.exports = e;
        }
            : function (e) {
            this["gaussian"] = e;
        });


        /***/
    },
    /* 2 */
    /***/ function (module, exports, __webpack_require__) {

        "use strict"

        var ndarray = __webpack_require__(3)
        var ops = __webpack_require__(6)
        var pool = __webpack_require__(11)

        function clone(array) {
            var dtype = array.dtype
            if (dtype === "generic" || dtype === "array") {
                dtype = "double"
            }
            var data = pool.malloc(array.size, dtype)
            var result = ndarray(data, array.shape)
            ops.assign(result, array)
            return result
        }

        exports.clone = clone

        function malloc(shape, dtype) {
            if (!dtype) {
                dtype = "double"
            }
            var sz = 1
            var stride = new Array(shape.length)
            for (var i = shape.length - 1; i >= 0; --i) {
                stride[i] = sz
                sz *= shape[i]
            }
            return ndarray(pool.malloc(sz, dtype), shape, stride, 0)
        }

        exports.malloc = malloc

        function free(array) {
            if (array.dtype === "generic" || array.dtype === "array") {
                return
            }
            pool.free(array.data)
        }

        exports.free = free

        function zeros(shape, dtype) {
            if (!dtype) {
                dtype = "double"
            }

            var sz = 1
            var stride = new Array(shape.length)
            for (var i = shape.length - 1; i >= 0; --i) {
                stride[i] = sz
                sz *= shape[i]
            }
            var buf = pool.malloc(sz, dtype)
            for (var i = 0; i < sz; ++i) {
                buf[i] = 0
            }
            return ndarray(buf, shape, stride, 0)
        }

        exports.zeros = zeros

        function ones(shape, dtype) {
            if (!dtype) {
                dtype = "double"
            }

            var sz = 1
            var stride = new Array(shape.length)
            for (var i = shape.length - 1; i >= 0; --i) {
                stride[i] = sz
                sz *= shape[i]
            }
            var buf = pool.malloc(sz, dtype)
            for (var i = 0; i < sz; ++i) {
                buf[i] = 1
            }
            return ndarray(buf, shape, stride, 0)
        }

        exports.ones = ones

        function eye(shape, dtype) {
            var i, offset
            if (!dtype) {
                dtype = "double"
            }

            var sz = 1
            var stride = new Array(shape.length)
            for (i = shape.length - 1; i >= 0; --i) {
                stride[i] = sz
                sz *= shape[i]
            }
            var buf = pool.malloc(sz, dtype)
            for (i = 0; i < sz; ++i) {
                buf[i] = 0
            }
            var mindim = Infinity
            var offsum = 0
            for (i = shape.length - 1; i >= 0; i--) {
                offsum += stride[i]
                mindim = Math.min(mindim, shape[i])
            }
            for (i = 0, offset = 0; i < mindim; i++, offset += offsum) {
                buf[offset] = 1
            }
            return ndarray(buf, shape, stride, 0)
        }

        exports.eye = eye


        /***/
    },
    /* 3 */
    /***/ function (module, exports, __webpack_require__) {

        var iota = __webpack_require__(4)
        var isBuffer = __webpack_require__(5)

        var hasTypedArrays = ((typeof Float64Array) !== "undefined")

        function compare1st(a, b) {
            return a[0] - b[0]
        }

        function order() {
            var stride = this.stride
            var terms = new Array(stride.length)
            var i
            for (i = 0; i < terms.length; ++i) {
                terms[i] = [Math.abs(stride[i]), i]
            }
            terms.sort(compare1st)
            var result = new Array(terms.length)
            for (i = 0; i < result.length; ++i) {
                result[i] = terms[i][1]
            }
            return result
        }

        function compileConstructor(dtype, dimension) {
            var className = ["View", dimension, "d", dtype].join("")
            if (dimension < 0) {
                className = "View_Nil" + dtype
            }
            var useGetters = (dtype === "generic")

            if (dimension === -1) {
                //Special case for trivial arrays
                var code =
                    "function " + className + "(a){this.data=a;};\
	var proto=" + className + ".prototype;\
	proto.dtype='" + dtype + "';\
	proto.index=function(){return -1};\
	proto.size=0;\
	proto.dimension=-1;\
	proto.shape=proto.stride=proto.order=[];\
	proto.lo=proto.hi=proto.transpose=proto.step=\
	function(){return new " + className + "(this.data);};\
	proto.get=proto.set=function(){};\
	proto.pick=function(){return null};\
	return function construct_" + className + "(a){return new " + className + "(a);}"
                var procedure = new Function(code)
                return procedure()
            } else if (dimension === 0) {
                //Special case for 0d arrays
                var code =
                    "function " + className + "(a,d) {\
	this.data = a;\
	this.offset = d\
	};\
	var proto=" + className + ".prototype;\
	proto.dtype='" + dtype + "';\
	proto.index=function(){return this.offset};\
	proto.dimension=0;\
	proto.size=1;\
	proto.shape=\
	proto.stride=\
	proto.order=[];\
	proto.lo=\
	proto.hi=\
	proto.transpose=\
	proto.step=function " + className + "_copy() {\
	return new " + className + "(this.data,this.offset)\
	};\
	proto.pick=function " + className + "_pick(){\
	return TrivialArray(this.data);\
	};\
	proto.valueOf=proto.get=function " + className + "_get(){\
	return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") +
                    "};\
	proto.set=function " + className + "_set(v){\
	return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
	};\
	return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}"
                var procedure = new Function("TrivialArray", code)
                return procedure(CACHED_CONSTRUCTORS[dtype][0])
            }

            var code = ["'use strict'"]

            //Create constructor for view
            var indices = iota(dimension)
            var args = indices.map(function (i) {
                return "i" + i
            })
            var index_str = "this.offset+" + indices.map(function (i) {
                    return "this.stride[" + i + "]*i" + i
                }).join("+")
            var shapeArg = indices.map(function (i) {
                return "b" + i
            }).join(",")
            var strideArg = indices.map(function (i) {
                return "c" + i
            }).join(",")
            code.push(
                "function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a",
                "this.shape=[" + shapeArg + "]",
                "this.stride=[" + strideArg + "]",
                "this.offset=d|0}",
                "var proto=" + className + ".prototype",
                "proto.dtype='" + dtype + "'",
                "proto.dimension=" + dimension)

            //view.size:
            code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
	return " + indices.map(function (i) {
                    return "this.shape[" + i + "]"
                }).join("*"),
                "}})")

            //view.order:
            if (dimension === 1) {
                code.push("proto.order=[0]")
            } else {
                code.push("Object.defineProperty(proto,'order',{get:")
                if (dimension < 4) {
                    code.push("function " + className + "_order(){")
                    if (dimension === 2) {
                        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
                    } else if (dimension === 3) {
                        code.push(
                            "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
	if(s0>s1){\
	if(s1>s2){\
	return [2,1,0];\
	}else if(s0>s2){\
	return [1,2,0];\
	}else{\
	return [1,0,2];\
	}\
	}else if(s0>s2){\
	return [2,0,1];\
	}else if(s2>s1){\
	return [0,1,2];\
	}else{\
	return [0,2,1];\
	}}})")
                    }
                } else {
                    code.push("ORDER})")
                }
            }

            //view.set(i0, ..., v):
            code.push(
                "proto.set=function " + className + "_set(" + args.join(",") + ",v){")
            if (useGetters) {
                code.push("return this.data.set(" + index_str + ",v)}")
            } else {
                code.push("return this.data[" + index_str + "]=v}")
            }

            //view.get(i0, ...):
            code.push("proto.get=function " + className + "_get(" + args.join(",") + "){")
            if (useGetters) {
                code.push("return this.data.get(" + index_str + ")}")
            } else {
                code.push("return this.data[" + index_str + "]}")
            }

            //view.index:
            code.push(
                "proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}")

            //view.hi():
            code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," +
                indices.map(function (i) {
                    return ["(typeof i", i, "!=='number'||i", i, "<0)?this.shape[", i, "]:i", i, "|0"].join("")
                }).join(",") + "," +
                indices.map(function (i) {
                    return "this.stride[" + i + "]"
                }).join(",") + ",this.offset)}")

            //view.lo():
            var a_vars = indices.map(function (i) {
                return "a" + i + "=this.shape[" + i + "]"
            })
            var c_vars = indices.map(function (i) {
                return "c" + i + "=this.stride[" + i + "]"
            })
            code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","))
            for (var i = 0; i < dimension; ++i) {
                code.push(
                    "if(typeof i" + i + "==='number'&&i" + i + ">=0){\
	d=i" + i + "|0;\
	b+=c" + i + "*d;\
	a" + i + "-=d}")
            }
            code.push("return new " + className + "(this.data," +
                indices.map(function (i) {
                    return "a" + i
                }).join(",") + "," +
                indices.map(function (i) {
                    return "c" + i
                }).join(",") + ",b)}")

            //view.step():
            code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " +
                indices.map(function (i) {
                    return "a" + i + "=this.shape[" + i + "]"
                }).join(",") + "," +
                indices.map(function (i) {
                    return "b" + i + "=this.stride[" + i + "]"
                }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil")
            for (var i = 0; i < dimension; ++i) {
                code.push(
                    "if(typeof i" + i + "==='number'){\
	d=i" + i + "|0;\
	if(d<0){\
	c+=b" + i + "*(a" + i + "-1);\
	a" + i + "=ceil(-a" + i + "/d)\
	}else{\
	a" + i + "=ceil(a" + i + "/d)\
	}\
	b" + i + "*=d\
	}")
            }
            code.push("return new " + className + "(this.data," +
                indices.map(function (i) {
                    return "a" + i
                }).join(",") + "," +
                indices.map(function (i) {
                    return "b" + i
                }).join(",") + ",c)}")

            //view.transpose():
            var tShape = new Array(dimension)
            var tStride = new Array(dimension)
            for (var i = 0; i < dimension; ++i) {
                tShape[i] = "a[i" + i + "]"
                tStride[i] = "b[i" + i + "]"
            }
            code.push("proto.transpose=function " + className + "_transpose(" + args + "){" +
                args.map(function (n, idx) {
                    return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"
                }).join(";"),
                "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}")

            //view.pick():
            code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset")
            for (var i = 0; i < dimension; ++i) {
                code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}")
            }
            code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

            //Add return statement
            code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," +
                indices.map(function (i) {
                    return "shape[" + i + "]"
                }).join(",") + "," +
                indices.map(function (i) {
                    return "stride[" + i + "]"
                }).join(",") + ",offset)}")

            //Compile procedure
            var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
            return procedure(CACHED_CONSTRUCTORS[dtype], order)
        }

        function arrayDType(data) {
            if (isBuffer(data)) {
                return "buffer"
            }
            if (hasTypedArrays) {
                switch (Object.prototype.toString.call(data)) {
                    case "[object Float64Array]":
                        return "float64"
                    case "[object Float32Array]":
                        return "float32"
                    case "[object Int8Array]":
                        return "int8"
                    case "[object Int16Array]":
                        return "int16"
                    case "[object Int32Array]":
                        return "int32"
                    case "[object Uint8Array]":
                        return "uint8"
                    case "[object Uint16Array]":
                        return "uint16"
                    case "[object Uint32Array]":
                        return "uint32"
                    case "[object Uint8ClampedArray]":
                        return "uint8_clamped"
                }
            }
            if (Array.isArray(data)) {
                return "array"
            }
            return "generic"
        }

        var CACHED_CONSTRUCTORS = {
                "float32": [],
                "float64": [],
                "int8": [],
                "int16": [],
                "int32": [],
                "uint8": [],
                "uint16": [],
                "uint32": [],
                "array": [],
                "uint8_clamped": [],
                "buffer": [],
                "generic": []
            }

            ;
        (function () {
            for (var id in CACHED_CONSTRUCTORS) {
                CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
            }
        });

        function wrappedNDArrayCtor(data, shape, stride, offset) {
            if (data === undefined) {
                var ctor = CACHED_CONSTRUCTORS.array[0]
                return ctor([])
            } else if (typeof data === "number") {
                data = [data]
            }
            if (shape === undefined) {
                shape = [data.length]
            }
            var d = shape.length
            if (stride === undefined) {
                stride = new Array(d)
                for (var i = d - 1, sz = 1; i >= 0; --i) {
                    stride[i] = sz
                    sz *= shape[i]
                }
            }
            if (offset === undefined) {
                offset = 0
                for (var i = 0; i < d; ++i) {
                    if (stride[i] < 0) {
                        offset -= (shape[i] - 1) * stride[i]
                    }
                }
            }
            var dtype = arrayDType(data)
            var ctor_list = CACHED_CONSTRUCTORS[dtype]
            while (ctor_list.length <= d + 1) {
                ctor_list.push(compileConstructor(dtype, ctor_list.length - 1))
            }
            var ctor = ctor_list[d + 1]
            return ctor(data, shape, stride, offset)
        }

        module.exports = wrappedNDArrayCtor


        /***/
    },
    /* 4 */
    /***/ function (module, exports) {

        "use strict"

        function iota(n) {
            var result = new Array(n)
            for (var i = 0; i < n; ++i) {
                result[i] = i
            }
            return result
        }

        module.exports = iota

        /***/
    },
    /* 5 */
    /***/ function (module, exports) {

        /*!
         * Determine if an object is a Buffer
         *
         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
         * @license  MIT
         */

        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function (obj) {
            return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
        }

        function isBuffer(obj) {
            return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
        }

        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
            return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
        }


        /***/
    },
    /* 6 */
    /***/ function (module, exports, __webpack_require__) {

        "use strict"

        var compile = __webpack_require__(7)

        var EmptyProc = {
            body: "",
            args: [],
            thisVars: [],
            localVars: []
        }

        function fixup(x) {
            if (!x) {
                return EmptyProc
            }
            for (var i = 0; i < x.args.length; ++i) {
                var a = x.args[i]
                if (i === 0) {
                    x.args[i] = {name: a, lvalue: true, rvalue: !!x.rvalue, count: x.count || 1}
                } else {
                    x.args[i] = {name: a, lvalue: false, rvalue: true, count: 1}
                }
            }
            if (!x.thisVars) {
                x.thisVars = []
            }
            if (!x.localVars) {
                x.localVars = []
            }
            return x
        }

        function pcompile(user_args) {
            return compile({
                args: user_args.args,
                pre: fixup(user_args.pre),
                body: fixup(user_args.body),
                post: fixup(user_args.proc),
                funcName: user_args.funcName
            })
        }

        function makeOp(user_args) {
            var args = []
            for (var i = 0; i < user_args.args.length; ++i) {
                args.push("a" + i)
            }
            var wrapper = new Function("P", [
                "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
            ].join(""))
            return wrapper(pcompile(user_args))
        }

        var assign_ops = {
                add: "+",
                sub: "-",
                mul: "*",
                div: "/",
                mod: "%",
                band: "&",
                bor: "|",
                bxor: "^",
                lshift: "<<",
                rshift: ">>",
                rrshift: ">>>"
            }
            ;
        (function () {
            for (var id in assign_ops) {
                var op = assign_ops[id]
                exports[id] = makeOp({
                    args: ["array", "array", "array"],
                    body: {
                        args: ["a", "b", "c"],
                        body: "a=b" + op + "c"
                    },
                    funcName: id
                })
                exports[id + "eq"] = makeOp({
                    args: ["array", "array"],
                    body: {
                        args: ["a", "b"],
                        body: "a" + op + "=b"
                    },
                    rvalue: true,
                    funcName: id + "eq"
                })
                exports[id + "s"] = makeOp({
                    args: ["array", "array", "scalar"],
                    body: {
                        args: ["a", "b", "s"],
                        body: "a=b" + op + "s"
                    },
                    funcName: id + "s"
                })
                exports[id + "seq"] = makeOp({
                    args: ["array", "scalar"],
                    body: {
                        args: ["a", "s"],
                        body: "a" + op + "=s"
                    },
                    rvalue: true,
                    funcName: id + "seq"
                })
            }
        })();

        var unary_ops = {
                not: "!",
                bnot: "~",
                neg: "-",
                recip: "1.0/"
            }
            ;
        (function () {
            for (var id in unary_ops) {
                var op = unary_ops[id]
                exports[id] = makeOp({
                    args: ["array", "array"],
                    body: {
                        args: ["a", "b"],
                        body: "a=" + op + "b"
                    },
                    funcName: id
                })
                exports[id + "eq"] = makeOp({
                    args: ["array"],
                    body: {
                        args: ["a"],
                        body: "a=" + op + "a"
                    },
                    rvalue: true,
                    count: 2,
                    funcName: id + "eq"
                })
            }
        })();

        var binary_ops = {
                and: "&&",
                or: "||",
                eq: "===",
                neq: "!==",
                lt: "<",
                gt: ">",
                leq: "<=",
                geq: ">="
            }
            ;
        (function () {
            for (var id in binary_ops) {
                var op = binary_ops[id]
                exports[id] = makeOp({
                    args: ["array", "array", "array"],
                    body: {
                        args: ["a", "b", "c"],
                        body: "a=b" + op + "c"
                    },
                    funcName: id
                })
                exports[id + "s"] = makeOp({
                    args: ["array", "array", "scalar"],
                    body: {
                        args: ["a", "b", "s"],
                        body: "a=b" + op + "s"
                    },
                    funcName: id + "s"
                })
                exports[id + "eq"] = makeOp({
                    args: ["array", "array"],
                    body: {
                        args: ["a", "b"],
                        body: "a=a" + op + "b"
                    },
                    rvalue: true,
                    count: 2,
                    funcName: id + "eq"
                })
                exports[id + "seq"] = makeOp({
                    args: ["array", "scalar"],
                    body: {
                        args: ["a", "s"],
                        body: "a=a" + op + "s"
                    },
                    rvalue: true,
                    count: 2,
                    funcName: id + "seq"
                })
            }
        })();

        var math_unary = [
                "abs",
                "acos",
                "asin",
                "atan",
                "ceil",
                "cos",
                "exp",
                "floor",
                "log",
                "round",
                "sin",
                "sqrt",
                "tan"
            ]
            ;
        (function () {
            for (var i = 0; i < math_unary.length; ++i) {
                var f = math_unary[i]
                exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a", "b"], body: "a=this_f(b)", thisVars: ["this_f"]},
                    funcName: f
                })
                exports[f + "eq"] = makeOp({
                    args: ["array"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a"], body: "a=this_f(a)", thisVars: ["this_f"]},
                    rvalue: true,
                    count: 2,
                    funcName: f + "eq"
                })
            }
        })();

        var math_comm = [
                "max",
                "min",
                "atan2",
                "pow"
            ]
            ;
        (function () {
            for (var i = 0; i < math_comm.length; ++i) {
                var f = math_comm[i]
                exports[f] = makeOp({
                    args: ["array", "array", "array"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"]},
                    funcName: f
                })
                exports[f + "s"] = makeOp({
                    args: ["array", "array", "scalar"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"]},
                    funcName: f + "s"
                })
                exports[f + "eq"] = makeOp({
                    args: ["array", "array"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"]},
                    rvalue: true,
                    count: 2,
                    funcName: f + "eq"
                })
                exports[f + "seq"] = makeOp({
                    args: ["array", "scalar"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"]},
                    rvalue: true,
                    count: 2,
                    funcName: f + "seq"
                })
            }
        })();

        var math_noncomm = [
                "atan2",
                "pow"
            ]
            ;
        (function () {
            for (var i = 0; i < math_noncomm.length; ++i) {
                var f = math_noncomm[i]
                exports[f + "op"] = makeOp({
                    args: ["array", "array", "array"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"]},
                    funcName: f + "op"
                })
                exports[f + "ops"] = makeOp({
                    args: ["array", "array", "scalar"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"]},
                    funcName: f + "ops"
                })
                exports[f + "opeq"] = makeOp({
                    args: ["array", "array"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"]},
                    rvalue: true,
                    count: 2,
                    funcName: f + "opeq"
                })
                exports[f + "opseq"] = makeOp({
                    args: ["array", "scalar"],
                    pre: {args: [], body: "this_f=Math." + f, thisVars: ["this_f"]},
                    body: {args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"]},
                    rvalue: true,
                    count: 2,
                    funcName: f + "opseq"
                })
            }
        })();

        exports.any = compile({
            args: ["array"],
            pre: EmptyProc,
            body: {
                args: [{name: "a", lvalue: false, rvalue: true, count: 1}],
                body: "if(a){return true}",
                localVars: [],
                thisVars: []
            },
            post: {args: [], localVars: [], thisVars: [], body: "return false"},
            funcName: "any"
        })

        exports.all = compile({
            args: ["array"],
            pre: EmptyProc,
            body: {
                args: [{name: "x", lvalue: false, rvalue: true, count: 1}],
                body: "if(!x){return false}",
                localVars: [],
                thisVars: []
            },
            post: {args: [], localVars: [], thisVars: [], body: "return true"},
            funcName: "all"
        })

        exports.sum = compile({
            args: ["array"],
            pre: {args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0"},
            body: {
                args: [{name: "a", lvalue: false, rvalue: true, count: 1}],
                body: "this_s+=a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {args: [], localVars: [], thisVars: ["this_s"], body: "return this_s"},
            funcName: "sum"
        })

        exports.prod = compile({
            args: ["array"],
            pre: {args: [], localVars: [], thisVars: ["this_s"], body: "this_s=1"},
            body: {
                args: [{name: "a", lvalue: false, rvalue: true, count: 1}],
                body: "this_s*=a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {args: [], localVars: [], thisVars: ["this_s"], body: "return this_s"},
            funcName: "prod"
        })

        exports.norm2squared = compile({
            args: ["array"],
            pre: {args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0"},
            body: {
                args: [{name: "a", lvalue: false, rvalue: true, count: 2}],
                body: "this_s+=a*a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {args: [], localVars: [], thisVars: ["this_s"], body: "return this_s"},
            funcName: "norm2squared"
        })

        exports.norm2 = compile({
            args: ["array"],
            pre: {args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0"},
            body: {
                args: [{name: "a", lvalue: false, rvalue: true, count: 2}],
                body: "this_s+=a*a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {args: [], localVars: [], thisVars: ["this_s"], body: "return Math.sqrt(this_s)"},
            funcName: "norm2"
        })


        exports.norminf = compile({
            args: ["array"],
            pre: {args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0"},
            body: {
                args: [{name: "a", lvalue: false, rvalue: true, count: 4}],
                body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {args: [], localVars: [], thisVars: ["this_s"], body: "return this_s"},
            funcName: "norminf"
        })

        exports.norm1 = compile({
            args: ["array"],
            pre: {args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0"},
            body: {
                args: [{name: "a", lvalue: false, rvalue: true, count: 3}],
                body: "this_s+=a<0?-a:a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {args: [], localVars: [], thisVars: ["this_s"], body: "return this_s"},
            funcName: "norm1"
        })

        exports.sup = compile({
            args: ["array"],
            pre: {
                body: "this_h=-Infinity",
                args: [],
                thisVars: ["this_h"],
                localVars: []
            },
            body: {
                body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
                args: [{"name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2}],
                thisVars: ["this_h"],
                localVars: []
            },
            post: {
                body: "return this_h",
                args: [],
                thisVars: ["this_h"],
                localVars: []
            }
        })

        exports.inf = compile({
            args: ["array"],
            pre: {
                body: "this_h=Infinity",
                args: [],
                thisVars: ["this_h"],
                localVars: []
            },
            body: {
                body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
                args: [{"name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2}],
                thisVars: ["this_h"],
                localVars: []
            },
            post: {
                body: "return this_h",
                args: [],
                thisVars: ["this_h"],
                localVars: []
            }
        })

        exports.argmin = compile({
            args: ["index", "array", "shape"],
            pre: {
                body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
                args: [
                    {name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0},
                    {name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0},
                    {name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1}
                ],
                thisVars: ["this_i", "this_v"],
                localVars: []
            },
            body: {
                body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                args: [
                    {name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2},
                    {name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2}],
                thisVars: ["this_i", "this_v"],
                localVars: ["_inline_1_k"]
            },
            post: {
                body: "{return this_i}",
                args: [],
                thisVars: ["this_i"],
                localVars: []
            }
        })

        exports.argmax = compile({
            args: ["index", "array", "shape"],
            pre: {
                body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
                args: [
                    {name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0},
                    {name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0},
                    {name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1}
                ],
                thisVars: ["this_i", "this_v"],
                localVars: []
            },
            body: {
                body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                args: [
                    {name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2},
                    {name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2}],
                thisVars: ["this_i", "this_v"],
                localVars: ["_inline_1_k"]
            },
            post: {
                body: "{return this_i}",
                args: [],
                thisVars: ["this_i"],
                localVars: []
            }
        })

        exports.random = makeOp({
            args: ["array"],
            pre: {args: [], body: "this_f=Math.random", thisVars: ["this_f"]},
            body: {args: ["a"], body: "a=this_f()", thisVars: ["this_f"]},
            funcName: "random"
        })

        exports.assign = makeOp({
            args: ["array", "array"],
            body: {args: ["a", "b"], body: "a=b"},
            funcName: "assign"
        })

        exports.assigns = makeOp({
            args: ["array", "scalar"],
            body: {args: ["a", "b"], body: "a=b"},
            funcName: "assigns"
        })


        exports.equals = compile({
            args: ["array", "array"],
            pre: EmptyProc,
            body: {
                args: [{name: "x", lvalue: false, rvalue: true, count: 1},
                    {name: "y", lvalue: false, rvalue: true, count: 1}],
                body: "if(x!==y){return false}",
                localVars: [],
                thisVars: []
            },
            post: {args: [], localVars: [], thisVars: [], body: "return true"},
            funcName: "equals"
        })


        /***/
    },
    /* 7 */
    /***/ function (module, exports, __webpack_require__) {

        "use strict"

        var createThunk = __webpack_require__(8)

        function Procedure() {
            this.argTypes = []
            this.shimArgs = []
            this.arrayArgs = []
            this.arrayBlockIndices = []
            this.scalarArgs = []
            this.offsetArgs = []
            this.offsetArgIndex = []
            this.indexArgs = []
            this.shapeArgs = []
            this.funcName = ""
            this.pre = null
            this.body = null
            this.post = null
            this.debug = false
        }

        function compileCwise(user_args) {
            //Create procedure
            var proc = new Procedure()

            //Parse blocks
            proc.pre = user_args.pre
            proc.body = user_args.body
            proc.post = user_args.post

            //Parse arguments
            var proc_args = user_args.args.slice(0)
            proc.argTypes = proc_args
            for (var i = 0; i < proc_args.length; ++i) {
                var arg_type = proc_args[i]
                if (arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
                    proc.argTypes[i] = "array"
                    proc.arrayArgs.push(i)
                    proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
                    proc.shimArgs.push("array" + i)
                    if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                        throw new Error("cwise: pre() block may not reference array args")
                    }
                    if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                        throw new Error("cwise: post() block may not reference array args")
                    }
                } else if (arg_type === "scalar") {
                    proc.scalarArgs.push(i)
                    proc.shimArgs.push("scalar" + i)
                } else if (arg_type === "index") {
                    proc.indexArgs.push(i)
                    if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                        throw new Error("cwise: pre() block may not reference array index")
                    }
                    if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                        throw new Error("cwise: body() block may not write to array index")
                    }
                    if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                        throw new Error("cwise: post() block may not reference array index")
                    }
                } else if (arg_type === "shape") {
                    proc.shapeArgs.push(i)
                    if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
                        throw new Error("cwise: pre() block may not write to array shape")
                    }
                    if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                        throw new Error("cwise: body() block may not write to array shape")
                    }
                    if (i < proc.post.args.length && proc.post.args[i].lvalue) {
                        throw new Error("cwise: post() block may not write to array shape")
                    }
                } else if (typeof arg_type === "object" && arg_type.offset) {
                    proc.argTypes[i] = "offset"
                    proc.offsetArgs.push({array: arg_type.array, offset: arg_type.offset})
                    proc.offsetArgIndex.push(i)
                } else {
                    throw new Error("cwise: Unknown argument type " + proc_args[i])
                }
            }

            //Make sure at least one array argument was specified
            if (proc.arrayArgs.length <= 0) {
                throw new Error("cwise: No array arguments specified")
            }

            //Make sure arguments are correct
            if (proc.pre.args.length > proc_args.length) {
                throw new Error("cwise: Too many arguments in pre() block")
            }
            if (proc.body.args.length > proc_args.length) {
                throw new Error("cwise: Too many arguments in body() block")
            }
            if (proc.post.args.length > proc_args.length) {
                throw new Error("cwise: Too many arguments in post() block")
            }

            //Check debug flag
            proc.debug = !!user_args.printCode || !!user_args.debug

            //Retrieve name
            proc.funcName = user_args.funcName || "cwise"

            //Read in block size
            proc.blockSize = user_args.blockSize || 64

            return createThunk(proc)
        }

        module.exports = compileCwise


        /***/
    },
    /* 8 */
    /***/ function (module, exports, __webpack_require__) {

        "use strict"

        // The function below is called when constructing a cwise function object, and does the following:
        // A function object is constructed which accepts as argument a compilation function and returns another function.
        // It is this other function that is eventually returned by createThunk, and this function is the one that actually
        // checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
        // The compilation passed to the first function object is used for compiling new functions.
        // Once this function object is created, it is called with compile as argument, where the first argument of compile
        // is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
        // So createThunk roughly works like this:
        // function createThunk(proc) {
        //   var thunk = function(compileBound) {
        //     var CACHED = {}
        //     return function(arrays and scalars) {
        //       if (dtype and order of arrays in CACHED) {
        //         var func = CACHED[dtype and order of arrays]
        //       } else {
        //         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
        //       }
        //       return func(arrays and scalars)
        //     }
        //   }
        //   return thunk(compile.bind1(proc))
        // }

        var compile = __webpack_require__(9)

        function createThunk(proc) {
            var code = ["'use strict'", "var CACHED={}"]
            var vars = []
            var thunkName = proc.funcName + "_cwise_thunk"

            //Build thunk
            code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
            var typesig = []
            var string_typesig = []
            var proc_args = [["array", proc.arrayArgs[0], ".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                Math.max(0, proc.arrayBlockIndices[0]), proc.arrayBlockIndices[0] < 0 ? ("," + proc.arrayBlockIndices[0] + ")") : ")"].join("")]
            var shapeLengthConditions = [], shapeConditions = []
            // Process array arguments
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                var j = proc.arrayArgs[i]
                vars.push(["t", j, "=array", j, ".dtype,",
                    "r", j, "=array", j, ".order"].join(""))
                typesig.push("t" + j)
                typesig.push("r" + j)
                string_typesig.push("t" + j)
                string_typesig.push("r" + j + ".join()")
                proc_args.push("array" + j + ".data")
                proc_args.push("array" + j + ".stride")
                proc_args.push("array" + j + ".offset|0")
                if (i > 0) { // Gather conditions to check for shape equality (ignoring block indices)
                    shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])))
                    shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]")
                }
            }
            // Check for shape equality
            if (proc.arrayArgs.length > 1) {
                code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
                code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
                code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
                code.push("}")
            }
            // Process scalar arguments
            for (var i = 0; i < proc.scalarArgs.length; ++i) {
                proc_args.push("scalar" + proc.scalarArgs[i])
            }
            // Check for cached function (and if not present, generate it)
            vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
            vars.push("proc=CACHED[type]")
            code.push("var " + vars.join(","))

            code.push(["if(!proc){",
                "CACHED[type]=proc=compile([", typesig.join(","), "])}",
                "return proc(", proc_args.join(","), ")}"].join(""))

            if (proc.debug) {
                console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
            }

            //Compile thunk
            var thunk = new Function("compile", code.join("\n"))
            return thunk(compile.bind(undefined, proc))
        }

        module.exports = createThunk


        /***/
    },
    /* 9 */
    /***/ function (module, exports, __webpack_require__) {

        "use strict"

        var uniq = __webpack_require__(10)

        // This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
        // TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
        function innerFill(order, proc, body) {
            var dimension = order.length
                , nargs = proc.arrayArgs.length
                , has_index = proc.indexArgs.length > 0
                , code = []
                , vars = []
                , idx = 0, pidx = 0, i, j
            for (i = 0; i < dimension; ++i) { // Iteration variables
                vars.push(["i", i, "=0"].join(""))
            }
            //Compute scan deltas
            for (j = 0; j < nargs; ++j) {
                for (i = 0; i < dimension; ++i) {
                    pidx = idx
                    idx = order[i]
                    if (i === 0) { // The innermost/fastest dimension's delta is simply its stride
                        vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""))
                    } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
                        vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""))
                    }
                }
            }
            code.push("var " + vars.join(","))
            //Scan loop
            for (i = dimension - 1; i >= 0; --i) { // Start at largest stride and work your way inwards
                idx = order[i]
                code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""))
            }
            //Push body of inner loop
            code.push(body)
            //Advance scan pointers
            for (i = 0; i < dimension; ++i) {
                pidx = idx
                idx = order[i]
                for (j = 0; j < nargs; ++j) {
                    code.push(["p", j, "+=d", j, "s", i].join(""))
                }
                if (has_index) {
                    if (i > 0) {
                        code.push(["index[", pidx, "]-=s", pidx].join(""))
                    }
                    code.push(["++index[", idx, "]"].join(""))
                }
                code.push("}")
            }
            return code.join("\n")
        }

        // Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
        // TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
        //       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
        function outerFill(matched, order, proc, body) {
            var dimension = order.length
                , nargs = proc.arrayArgs.length
                , blockSize = proc.blockSize
                , has_index = proc.indexArgs.length > 0
                , code = []
            for (var i = 0; i < nargs; ++i) {
                code.push(["var offset", i, "=p", i].join(""))
            }
            //Generate loops for unmatched dimensions
            // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
            // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
            for (var i = matched; i < dimension; ++i) {
                code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
                code.push(["if(j", i, "<", blockSize, "){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
                code.push(["s", order[i], "=j", i].join(""))
                code.push(["j", i, "=0"].join(""))
                code.push(["}else{s", order[i], "=", blockSize].join(""))
                code.push(["j", i, "-=", blockSize, "}"].join(""))
                if (has_index) {
                    code.push(["index[", order[i], "]=j", i].join(""))
                }
            }
            for (var i = 0; i < nargs; ++i) {
                var indexStr = ["offset" + i]
                for (var j = matched; j < dimension; ++j) {
                    indexStr.push(["j", j, "*t", i, "p", order[j]].join(""))
                }
                code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""))
            }
            code.push(innerFill(order, proc, body))
            for (var i = matched; i < dimension; ++i) {
                code.push("}")
            }
            return code.join("\n")
        }

        //Count the number of compatible inner orders
        // This is the length of the longest common prefix of the arrays in orders.
        // Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
        // This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
        function countMatches(orders) {
            var matched = 0, dimension = orders[0].length
            while (matched < dimension) {
                for (var j = 1; j < orders.length; ++j) {
                    if (orders[j][matched] !== orders[0][matched]) {
                        return matched
                    }
                }
                ++matched
            }
            return matched
        }

        //Processes a block according to the given data types
        // Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
        function processBlock(block, proc, dtypes) {
            var code = block.body
            var pre = []
            var post = []
            for (var i = 0; i < block.args.length; ++i) {
                var carg = block.args[i]
                if (carg.count <= 0) {
                    continue
                }
                var re = new RegExp(carg.name, "g")
                var ptrStr = ""
                var arrNum = proc.arrayArgs.indexOf(i)
                switch (proc.argTypes[i]) {
                    case "offset":
                        var offArgIndex = proc.offsetArgIndex.indexOf(i)
                        var offArg = proc.offsetArgs[offArgIndex]
                        arrNum = offArg.array
                        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
                    case "array":
                        ptrStr = "p" + arrNum + ptrStr
                        var localStr = "l" + i
                        var arrStr = "a" + arrNum
                        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
                            if (carg.count === 1) { // Argument/array used only once(?)
                                if (dtypes[arrNum] === "generic") {
                                    if (carg.lvalue) {
                                        pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                                        code = code.replace(re, localStr)
                                        post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""))
                                    } else {
                                        code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
                                    }
                                } else {
                                    code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
                                }
                            } else if (dtypes[arrNum] === "generic") {
                                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                                code = code.replace(re, localStr)
                                if (carg.lvalue) {
                                    post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""))
                                }
                            } else {
                                pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                                code = code.replace(re, localStr)
                                if (carg.lvalue) {
                                    post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
                                }
                            }
                        } else { // Argument to body is a "block"
                            var reStrArr = [carg.name], ptrStrArr = [ptrStr]
                            for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
                                reStrArr.push("\\s*\\[([^\\]]+)\\]")
                                ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j) // Matched index times stride
                            }
                            re = new RegExp(reStrArr.join(""), "g")
                            ptrStr = ptrStrArr.join("+")
                            if (dtypes[arrNum] === "generic") {
                                /*if(carg.lvalue) {
                                 pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                                 code = code.replace(re, localStr)
                                 post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
                                 } else {
                                 code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
                                 }*/
                                throw new Error("cwise: Generic arrays not supported in combination with blocks!")
                            } else {
                                // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
                                code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
                            }
                        }
                        break
                    case "scalar":
                        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
                        break
                    case "index":
                        code = code.replace(re, "index")
                        break
                    case "shape":
                        code = code.replace(re, "shape")
                        break
                }
            }
            return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
        }

        function typeSummary(dtypes) {
            var summary = new Array(dtypes.length)
            var allEqual = true
            for (var i = 0; i < dtypes.length; ++i) {
                var t = dtypes[i]
                var digits = t.match(/\d+/)
                if (!digits) {
                    digits = ""
                } else {
                    digits = digits[0]
                }
                if (t.charAt(0) === 0) {
                    summary[i] = "u" + t.charAt(1) + digits
                } else {
                    summary[i] = t.charAt(0) + digits
                }
                if (i > 0) {
                    allEqual = allEqual && summary[i] === summary[i - 1]
                }
            }
            if (allEqual) {
                return summary[0]
            }
            return summary.join("")
        }

        //Generates a cwise operator
        function generateCWiseOp(proc, typesig) {

            //Compute dimension
            // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
            var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0])) | 0
            var orders = new Array(proc.arrayArgs.length)
            var dtypes = new Array(proc.arrayArgs.length)
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                dtypes[i] = typesig[2 * i]
                orders[i] = typesig[2 * i + 1]
            }

            //Determine where block and loop indices start and end
            var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
            var loopBegin = [], loopEnd = [] // These indices are iterated over
            var loopOrders = [] // orders restricted to the loop indices
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                if (proc.arrayBlockIndices[i] < 0) {
                    loopBegin.push(0)
                    loopEnd.push(dimension)
                    blockBegin.push(dimension)
                    blockEnd.push(dimension + proc.arrayBlockIndices[i])
                } else {
                    loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
                    loopEnd.push(proc.arrayBlockIndices[i] + dimension)
                    blockBegin.push(0)
                    blockEnd.push(proc.arrayBlockIndices[i])
                }
                var newOrder = []
                for (var j = 0; j < orders[i].length; j++) {
                    if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
                        newOrder.push(orders[i][j] - loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
                    }
                }
                loopOrders.push(newOrder)
            }

            //First create arguments for procedure
            var arglist = ["SS"] // SS is the overall shape over which we iterate
            var code = ["'use strict'"]
            var vars = []

            for (var j = 0; j < dimension; ++j) {
                vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
            }
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                arglist.push("a" + i) // Actual data array
                arglist.push("t" + i) // Strides
                arglist.push("p" + i) // Offset in the array at which the data starts (also used for iterating over the data)

                for (var j = 0; j < dimension; ++j) { // Unpack the strides into vars for looping
                    vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""))
                }

                for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
                    vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""))
                }
            }
            for (var i = 0; i < proc.scalarArgs.length; ++i) {
                arglist.push("Y" + i)
            }
            if (proc.shapeArgs.length > 0) {
                vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
            }
            if (proc.indexArgs.length > 0) {
                // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
                var zeros = new Array(dimension)
                for (var i = 0; i < dimension; ++i) {
                    zeros[i] = "0"
                }
                vars.push(["index=[", zeros.join(","), "]"].join(""))
            }
            for (var i = 0; i < proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
                var off_arg = proc.offsetArgs[i]
                var init_string = []
                for (var j = 0; j < off_arg.offset.length; ++j) {
                    if (off_arg.offset[j] === 0) {
                        continue
                    } else if (off_arg.offset[j] === 1) {
                        init_string.push(["t", off_arg.array, "p", j].join(""))
                    } else {
                        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
                    }
                }
                if (init_string.length === 0) {
                    vars.push("q" + i + "=0")
                } else {
                    vars.push(["q", i, "=", init_string.join("+")].join(""))
                }
            }

            //Prepare this variables
            var thisVars = uniq([].concat(proc.pre.thisVars)
                .concat(proc.body.thisVars)
                .concat(proc.post.thisVars))
            vars = vars.concat(thisVars)
            code.push("var " + vars.join(","))
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                code.push("p" + i + "|=0")
            }

            //Inline prelude
            if (proc.pre.body.length > 3) {
                code.push(processBlock(proc.pre, proc, dtypes))
            }

            //Process body
            var body = processBlock(proc.body, proc, dtypes)
            var matched = countMatches(loopOrders)
            if (matched < dimension) {
                code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
            } else {
                code.push(innerFill(loopOrders[0], proc, body))
            }

            //Inline epilog
            if (proc.post.body.length > 3) {
                code.push(processBlock(proc.post, proc, dtypes))
            }

            if (proc.debug) {
                console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
            }

            var loopName = [(proc.funcName || "unnamed"), "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("")
            var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""))
            return f()
        }

        module.exports = generateCWiseOp


        /***/
    },
    /* 10 */
    /***/ function (module, exports) {

        "use strict"

        function unique_pred(list, compare) {
            var ptr = 1
                , len = list.length
                , a = list[0], b = list[0]
            for (var i = 1; i < len; ++i) {
                b = a
                a = list[i]
                if (compare(a, b)) {
                    if (i === ptr) {
                        ptr++
                        continue
                    }
                    list[ptr++] = a
                }
            }
            list.length = ptr
            return list
        }

        function unique_eq(list) {
            var ptr = 1
                , len = list.length
                , a = list[0], b = list[0]
            for (var i = 1; i < len; ++i, b = a) {
                b = a
                a = list[i]
                if (a !== b) {
                    if (i === ptr) {
                        ptr++
                        continue
                    }
                    list[ptr++] = a
                }
            }
            list.length = ptr
            return list
        }

        function unique(list, compare, sorted) {
            if (list.length === 0) {
                return list
            }
            if (compare) {
                if (!sorted) {
                    list.sort(compare)
                }
                return unique_pred(list, compare)
            }
            if (!sorted) {
                list.sort()
            }
            return unique_eq(list)
        }

        module.exports = unique


        /***/
    },
    /* 11 */
    /***/ function (module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function (global, Buffer) {
            'use strict'

            var bits = __webpack_require__(16)
            var dup = __webpack_require__(17)

            //Legacy pool support
            if (!global.__TYPEDARRAY_POOL) {
                global.__TYPEDARRAY_POOL = {
                    UINT8: dup([32, 0])
                    , UINT16: dup([32, 0])
                    , UINT32: dup([32, 0])
                    , INT8: dup([32, 0])
                    , INT16: dup([32, 0])
                    , INT32: dup([32, 0])
                    , FLOAT: dup([32, 0])
                    , DOUBLE: dup([32, 0])
                    , DATA: dup([32, 0])
                    , UINT8C: dup([32, 0])
                    , BUFFER: dup([32, 0])
                }
            }

            var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
            var POOL = global.__TYPEDARRAY_POOL

            //Upgrade pool
            if (!POOL.UINT8C) {
                POOL.UINT8C = dup([32, 0])
            }
            if (!POOL.BUFFER) {
                POOL.BUFFER = dup([32, 0])
            }

            //New technique: Only allocate from ArrayBufferView and Buffer
            var DATA = POOL.DATA
                , BUFFER = POOL.BUFFER

            exports.free = function free(array) {
                if (Buffer.isBuffer(array)) {
                    BUFFER[bits.log2(array.length)].push(array)
                } else {
                    if (Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
                        array = array.buffer
                    }
                    if (!array) {
                        return
                    }
                    var n = array.length || array.byteLength
                    var log_n = bits.log2(n) | 0
                    DATA[log_n].push(array)
                }
            }

            function freeArrayBuffer(buffer) {
                if (!buffer) {
                    return
                }
                var n = buffer.length || buffer.byteLength
                var log_n = bits.log2(n)
                DATA[log_n].push(buffer)
            }

            function freeTypedArray(array) {
                freeArrayBuffer(array.buffer)
            }

            exports.freeUint8 =
                exports.freeUint16 =
                    exports.freeUint32 =
                        exports.freeInt8 =
                            exports.freeInt16 =
                                exports.freeInt32 =
                                    exports.freeFloat32 =
                                        exports.freeFloat =
                                            exports.freeFloat64 =
                                                exports.freeDouble =
                                                    exports.freeUint8Clamped =
                                                        exports.freeDataView = freeTypedArray

            exports.freeArrayBuffer = freeArrayBuffer

            exports.freeBuffer = function freeBuffer(array) {
                BUFFER[bits.log2(array.length)].push(array)
            }

            exports.malloc = function malloc(n, dtype) {
                if (dtype === undefined || dtype === 'arraybuffer') {
                    return mallocArrayBuffer(n)
                } else {
                    switch (dtype) {
                        case 'uint8':
                            return mallocUint8(n)
                        case 'uint16':
                            return mallocUint16(n)
                        case 'uint32':
                            return mallocUint32(n)
                        case 'int8':
                            return mallocInt8(n)
                        case 'int16':
                            return mallocInt16(n)
                        case 'int32':
                            return mallocInt32(n)
                        case 'float':
                        case 'float32':
                            return mallocFloat(n)
                        case 'double':
                        case 'float64':
                            return mallocDouble(n)
                        case 'uint8_clamped':
                            return mallocUint8Clamped(n)
                        case 'buffer':
                            return mallocBuffer(n)
                        case 'data':
                        case 'dataview':
                            return mallocDataView(n)

                        default:
                            return null
                    }
                }
                return null
            }

            function mallocArrayBuffer(n) {
                var n = bits.nextPow2(n)
                var log_n = bits.log2(n)
                var d = DATA[log_n]
                if (d.length > 0) {
                    return d.pop()
                }
                return new ArrayBuffer(n)
            }

            exports.mallocArrayBuffer = mallocArrayBuffer

            function mallocUint8(n) {
                return new Uint8Array(mallocArrayBuffer(n), 0, n)
            }

            exports.mallocUint8 = mallocUint8

            function mallocUint16(n) {
                return new Uint16Array(mallocArrayBuffer(2 * n), 0, n)
            }

            exports.mallocUint16 = mallocUint16

            function mallocUint32(n) {
                return new Uint32Array(mallocArrayBuffer(4 * n), 0, n)
            }

            exports.mallocUint32 = mallocUint32

            function mallocInt8(n) {
                return new Int8Array(mallocArrayBuffer(n), 0, n)
            }

            exports.mallocInt8 = mallocInt8

            function mallocInt16(n) {
                return new Int16Array(mallocArrayBuffer(2 * n), 0, n)
            }

            exports.mallocInt16 = mallocInt16

            function mallocInt32(n) {
                return new Int32Array(mallocArrayBuffer(4 * n), 0, n)
            }

            exports.mallocInt32 = mallocInt32

            function mallocFloat(n) {
                return new Float32Array(mallocArrayBuffer(4 * n), 0, n)
            }

            exports.mallocFloat32 = exports.mallocFloat = mallocFloat

            function mallocDouble(n) {
                return new Float64Array(mallocArrayBuffer(8 * n), 0, n)
            }

            exports.mallocFloat64 = exports.mallocDouble = mallocDouble

            function mallocUint8Clamped(n) {
                if (hasUint8C) {
                    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
                } else {
                    return mallocUint8(n)
                }
            }

            exports.mallocUint8Clamped = mallocUint8Clamped

            function mallocDataView(n) {
                return new DataView(mallocArrayBuffer(n), 0, n)
            }

            exports.mallocDataView = mallocDataView

            function mallocBuffer(n) {
                n = bits.nextPow2(n)
                var log_n = bits.log2(n)
                var cache = BUFFER[log_n]
                if (cache.length > 0) {
                    return cache.pop()
                }
                return new Buffer(n)
            }

            exports.mallocBuffer = mallocBuffer

            exports.clearCache = function clearCache() {
                for (var i = 0; i < 32; ++i) {
                    POOL.UINT8[i].length = 0
                    POOL.UINT16[i].length = 0
                    POOL.UINT32[i].length = 0
                    POOL.INT8[i].length = 0
                    POOL.INT16[i].length = 0
                    POOL.INT32[i].length = 0
                    POOL.FLOAT[i].length = 0
                    POOL.DOUBLE[i].length = 0
                    POOL.UINT8C[i].length = 0
                    DATA[i].length = 0
                    BUFFER[i].length = 0
                }
            }
            /* WEBPACK VAR INJECTION */
        }.call(exports, (function () {
            return this;
        }()), __webpack_require__(12).Buffer))

        /***/
    },
    /* 12 */
    /***/ function (module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function (global) {/*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
         * @license  MIT
         */
            /* eslint-disable no-proto */

            'use strict'

            var base64 = __webpack_require__(13)
            var ieee754 = __webpack_require__(14)
            var isArray = __webpack_require__(15)

            exports.Buffer = Buffer
            exports.SlowBuffer = SlowBuffer
            exports.INSPECT_MAX_BYTES = 50

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Use Object implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * Due to various browser bugs, sometimes the Object implementation will be used even
             * when the browser supports typed arrays.
             *
             * Note:
             *
             *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
             *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
             *
             *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
             *
             *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
             *     incorrect length in some situations.

             * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
             * get the Object implementation, which is slower but behaves correctly.
             */
            Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
                ? global.TYPED_ARRAY_SUPPORT
                : typedArraySupport()

            /*
             * Export kMaxLength after typed array support is determined.
             */
            exports.kMaxLength = kMaxLength()

            function typedArraySupport() {
                try {
                    var arr = new Uint8Array(1)
                    arr.__proto__ = {
                        __proto__: Uint8Array.prototype, foo: function () {
                            return 42
                        }
                    }
                    return arr.foo() === 42 && // typed array instances can be augmented
                        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
                } catch (e) {
                    return false
                }
            }

            function kMaxLength() {
                return Buffer.TYPED_ARRAY_SUPPORT
                    ? 0x7fffffff
                    : 0x3fffffff
            }

            function createBuffer(that, length) {
                if (kMaxLength() < length) {
                    throw new RangeError('Invalid typed array length')
                }
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    // Return an augmented `Uint8Array` instance, for best performance
                    that = new Uint8Array(length)
                    that.__proto__ = Buffer.prototype
                } else {
                    // Fallback: Return an object instance of the Buffer class
                    if (that === null) {
                        that = new Buffer(length)
                    }
                    that.length = length
                }

                return that
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer(arg, encodingOrOffset, length) {
                if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                    return new Buffer(arg, encodingOrOffset, length)
                }

                // Common case.
                if (typeof arg === 'number') {
                    if (typeof encodingOrOffset === 'string') {
                        throw new Error(
                            'If encoding is specified then the first argument must be a string'
                        )
                    }
                    return allocUnsafe(this, arg)
                }
                return from(this, arg, encodingOrOffset, length)
            }

            Buffer.poolSize = 8192 // not used by this implementation

            // TODO: Legacy, not needed anymore. Remove in next major version.
            Buffer._augment = function (arr) {
                arr.__proto__ = Buffer.prototype
                return arr
            }

            function from(that, value, encodingOrOffset, length) {
                if (typeof value === 'number') {
                    throw new TypeError('"value" argument must not be a number')
                }

                if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                    return fromArrayBuffer(that, value, encodingOrOffset, length)
                }

                if (typeof value === 'string') {
                    return fromString(that, value, encodingOrOffset)
                }

                return fromObject(that, value)
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer.from = function (value, encodingOrOffset, length) {
                return from(null, value, encodingOrOffset, length)
            }

            if (Buffer.TYPED_ARRAY_SUPPORT) {
                Buffer.prototype.__proto__ = Uint8Array.prototype
                Buffer.__proto__ = Uint8Array
                if (typeof Symbol !== 'undefined' && Symbol.species &&
                    Buffer[Symbol.species] === Buffer) {
                    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
                    Object.defineProperty(Buffer, Symbol.species, {
                        value: null,
                        configurable: true
                    })
                }
            }

            function assertSize(size) {
                if (typeof size !== 'number') {
                    throw new TypeError('"size" argument must be a number')
                } else if (size < 0) {
                    throw new RangeError('"size" argument must not be negative')
                }
            }

            function alloc(that, size, fill, encoding) {
                assertSize(size)
                if (size <= 0) {
                    return createBuffer(that, size)
                }
                if (fill !== undefined) {
                    // Only pay attention to encoding if it's a string. This
                    // prevents accidentally sending in a number that would
                    // be interpretted as a start offset.
                    return typeof encoding === 'string'
                        ? createBuffer(that, size).fill(fill, encoding)
                        : createBuffer(that, size).fill(fill)
                }
                return createBuffer(that, size)
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer.alloc = function (size, fill, encoding) {
                return alloc(null, size, fill, encoding)
            }

            function allocUnsafe(that, size) {
                assertSize(size)
                that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) {
                    for (var i = 0; i < size; ++i) {
                        that[i] = 0
                    }
                }
                return that
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer.allocUnsafe = function (size) {
                return allocUnsafe(null, size)
            }
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer.allocUnsafeSlow = function (size) {
                return allocUnsafe(null, size)
            }

            function fromString(that, string, encoding) {
                if (typeof encoding !== 'string' || encoding === '') {
                    encoding = 'utf8'
                }

                if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError('"encoding" must be a valid string encoding')
                }

                var length = byteLength(string, encoding) | 0
                that = createBuffer(that, length)

                var actual = that.write(string, encoding)

                if (actual !== length) {
                    // Writing a hex string, for example, that contains invalid characters will
                    // cause everything after the first invalid character to be ignored. (e.g.
                    // 'abxxcd' will be treated as 'ab')
                    that = that.slice(0, actual)
                }

                return that
            }

            function fromArrayLike(that, array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0
                that = createBuffer(that, length)
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }

            function fromArrayBuffer(that, array, byteOffset, length) {
                array.byteLength // this throws if `array` is not a valid ArrayBuffer

                if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError('\'offset\' is out of bounds')
                }

                if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError('\'length\' is out of bounds')
                }

                if (byteOffset === undefined && length === undefined) {
                    array = new Uint8Array(array)
                } else if (length === undefined) {
                    array = new Uint8Array(array, byteOffset)
                } else {
                    array = new Uint8Array(array, byteOffset, length)
                }

                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    // Return an augmented `Uint8Array` instance, for best performance
                    that = array
                    that.__proto__ = Buffer.prototype
                } else {
                    // Fallback: Return an object instance of the Buffer class
                    that = fromArrayLike(that, array)
                }
                return that
            }

            function fromObject(that, obj) {
                if (Buffer.isBuffer(obj)) {
                    var len = checked(obj.length) | 0
                    that = createBuffer(that, len)

                    if (that.length === 0) {
                        return that
                    }

                    obj.copy(that, 0, 0, len)
                    return that
                }

                if (obj) {
                    if ((typeof ArrayBuffer !== 'undefined' &&
                        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                        if (typeof obj.length !== 'number' || isnan(obj.length)) {
                            return createBuffer(that, 0)
                        }
                        return fromArrayLike(that, obj)
                    }

                    if (obj.type === 'Buffer' && isArray(obj.data)) {
                        return fromArrayLike(that, obj.data)
                    }
                }

                throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
            }

            function checked(length) {
                // Note: cannot use `length < kMaxLength()` here because that fails when
                // length is NaN (which is otherwise coerced to zero.)
                if (length >= kMaxLength()) {
                    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                        'size: 0x' + kMaxLength().toString(16) + ' bytes')
                }
                return length | 0
            }

            function SlowBuffer(length) {
                if (+length != length) { // eslint-disable-line eqeqeq
                    length = 0
                }
                return Buffer.alloc(+length)
            }

            Buffer.isBuffer = function isBuffer(b) {
                return !!(b != null && b._isBuffer)
            }

            Buffer.compare = function compare(a, b) {
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError('Arguments must be Buffers')
                }

                if (a === b) return 0

                var x = a.length
                var y = b.length

                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                        x = a[i]
                        y = b[i]
                        break
                    }
                }

                if (x < y) return -1
                if (y < x) return 1
                return 0
            }

            Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return true
                    default:
                        return false
                }
            }

            Buffer.concat = function concat(list, length) {
                if (!isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers')
                }

                if (list.length === 0) {
                    return Buffer.alloc(0)
                }

                var i
                if (length === undefined) {
                    length = 0
                    for (i = 0; i < list.length; ++i) {
                        length += list[i].length
                    }
                }

                var buffer = Buffer.allocUnsafe(length)
                var pos = 0
                for (i = 0; i < list.length; ++i) {
                    var buf = list[i]
                    if (!Buffer.isBuffer(buf)) {
                        throw new TypeError('"list" argument must be an Array of Buffers')
                    }
                    buf.copy(buffer, pos)
                    pos += buf.length
                }
                return buffer
            }

            function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) {
                    return string.length
                }
                if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
                    (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                    return string.byteLength
                }
                if (typeof string !== 'string') {
                    string = '' + string
                }

                var len = string.length
                if (len === 0) return 0

                // Use a for loop to avoid recursion
                var loweredCase = false
                for (; ;) {
                    switch (encoding) {
                        case 'ascii':
                        case 'latin1':
                        case 'binary':
                            return len
                        case 'utf8':
                        case 'utf-8':
                        case undefined:
                            return utf8ToBytes(string).length
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return len * 2
                        case 'hex':
                            return len >>> 1
                        case 'base64':
                            return base64ToBytes(string).length
                        default:
                            if (loweredCase) return utf8ToBytes(string).length // assume utf8
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }

            Buffer.byteLength = byteLength

            function slowToString(encoding, start, end) {
                var loweredCase = false

                // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                // property of a typed array.

                // This behaves neither like String nor Uint8Array in that we set start/end
                // to their upper/lower bounds if the value passed is out of range.
                // undefined is handled specially as per ECMA-262 6th Edition,
                // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                if (start === undefined || start < 0) {
                    start = 0
                }
                // Return early if start > this.length. Done here to prevent potential uint32
                // coercion fail below.
                if (start > this.length) {
                    return ''
                }

                if (end === undefined || end > this.length) {
                    end = this.length
                }

                if (end <= 0) {
                    return ''
                }

                // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                end >>>= 0
                start >>>= 0

                if (end <= start) {
                    return ''
                }

                if (!encoding) encoding = 'utf8'

                while (true) {
                    switch (encoding) {
                        case 'hex':
                            return hexSlice(this, start, end)

                        case 'utf8':
                        case 'utf-8':
                            return utf8Slice(this, start, end)

                        case 'ascii':
                            return asciiSlice(this, start, end)

                        case 'latin1':
                        case 'binary':
                            return latin1Slice(this, start, end)

                        case 'base64':
                            return base64Slice(this, start, end)

                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return utf16leSlice(this, start, end)

                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = (encoding + '').toLowerCase()
                            loweredCase = true
                    }
                }
            }

            // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
            // Buffer instances.
            Buffer.prototype._isBuffer = true

            function swap(b, n, m) {
                var i = b[n]
                b[n] = b[m]
                b[m] = i
            }

            Buffer.prototype.swap16 = function swap16() {
                var len = this.length
                if (len % 2 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 16-bits')
                }
                for (var i = 0; i < len; i += 2) {
                    swap(this, i, i + 1)
                }
                return this
            }

            Buffer.prototype.swap32 = function swap32() {
                var len = this.length
                if (len % 4 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 32-bits')
                }
                for (var i = 0; i < len; i += 4) {
                    swap(this, i, i + 3)
                    swap(this, i + 1, i + 2)
                }
                return this
            }

            Buffer.prototype.swap64 = function swap64() {
                var len = this.length
                if (len % 8 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 64-bits')
                }
                for (var i = 0; i < len; i += 8) {
                    swap(this, i, i + 7)
                    swap(this, i + 1, i + 6)
                    swap(this, i + 2, i + 5)
                    swap(this, i + 3, i + 4)
                }
                return this
            }

            Buffer.prototype.toString = function toString() {
                var length = this.length | 0
                if (length === 0) return ''
                if (arguments.length === 0) return utf8Slice(this, 0, length)
                return slowToString.apply(this, arguments)
            }

            Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                if (this === b) return true
                return Buffer.compare(this, b) === 0
            }

            Buffer.prototype.inspect = function inspect() {
                var str = ''
                var max = exports.INSPECT_MAX_BYTES
                if (this.length > 0) {
                    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                    if (this.length > max) str += ' ... '
                }
                return '<Buffer ' + str + '>'
            }

            Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (!Buffer.isBuffer(target)) {
                    throw new TypeError('Argument must be a Buffer')
                }

                if (start === undefined) {
                    start = 0
                }
                if (end === undefined) {
                    end = target ? target.length : 0
                }
                if (thisStart === undefined) {
                    thisStart = 0
                }
                if (thisEnd === undefined) {
                    thisEnd = this.length
                }

                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError('out of range index')
                }

                if (thisStart >= thisEnd && start >= end) {
                    return 0
                }
                if (thisStart >= thisEnd) {
                    return -1
                }
                if (start >= end) {
                    return 1
                }

                start >>>= 0
                end >>>= 0
                thisStart >>>= 0
                thisEnd >>>= 0

                if (this === target) return 0

                var x = thisEnd - thisStart
                var y = end - start
                var len = Math.min(x, y)

                var thisCopy = this.slice(thisStart, thisEnd)
                var targetCopy = target.slice(start, end)

                for (var i = 0; i < len; ++i) {
                    if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i]
                        y = targetCopy[i]
                        break
                    }
                }

                if (x < y) return -1
                if (y < x) return 1
                return 0
            }

            // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
            // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
            //
            // Arguments:
            // - buffer - a Buffer to search
            // - val - a string, Buffer, or number
            // - byteOffset - an index into `buffer`; will be clamped to an int32
            // - encoding - an optional encoding, relevant is val is a string
            // - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                // Empty buffer means no match
                if (buffer.length === 0) return -1

                // Normalize byteOffset
                if (typeof byteOffset === 'string') {
                    encoding = byteOffset
                    byteOffset = 0
                } else if (byteOffset > 0x7fffffff) {
                    byteOffset = 0x7fffffff
                } else if (byteOffset < -0x80000000) {
                    byteOffset = -0x80000000
                }
                byteOffset = +byteOffset  // Coerce to Number.
                if (isNaN(byteOffset)) {
                    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                    byteOffset = dir ? 0 : (buffer.length - 1)
                }

                // Normalize byteOffset: negative offsets start from the end of the buffer
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset
                if (byteOffset >= buffer.length) {
                    if (dir) return -1
                    else byteOffset = buffer.length - 1
                } else if (byteOffset < 0) {
                    if (dir) byteOffset = 0
                    else return -1
                }

                // Normalize val
                if (typeof val === 'string') {
                    val = Buffer.from(val, encoding)
                }

                // Finally, search either indexOf (if dir is true) or lastIndexOf
                if (Buffer.isBuffer(val)) {
                    // Special case: looking for empty string/buffer always fails
                    if (val.length === 0) {
                        return -1
                    }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
                } else if (typeof val === 'number') {
                    val = val & 0xFF // Search for a byte value [0-255]
                    if (Buffer.TYPED_ARRAY_SUPPORT &&
                        typeof Uint8Array.prototype.indexOf === 'function') {
                        if (dir) {
                            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                        }
                    }
                    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
                }

                throw new TypeError('val must be string, number or Buffer')
            }

            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1
                var arrLength = arr.length
                var valLength = val.length

                if (encoding !== undefined) {
                    encoding = String(encoding).toLowerCase()
                    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                        encoding === 'utf16le' || encoding === 'utf-16le') {
                        if (arr.length < 2 || val.length < 2) {
                            return -1
                        }
                        indexSize = 2
                        arrLength /= 2
                        valLength /= 2
                        byteOffset /= 2
                    }
                }

                function read(buf, i) {
                    if (indexSize === 1) {
                        return buf[i]
                    } else {
                        return buf.readUInt16BE(i * indexSize)
                    }
                }

                var i
                if (dir) {
                    var foundIndex = -1
                    for (i = byteOffset; i < arrLength; i++) {
                        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                            if (foundIndex === -1) foundIndex = i
                            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                        } else {
                            if (foundIndex !== -1) i -= i - foundIndex
                            foundIndex = -1
                        }
                    }
                } else {
                    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
                    for (i = byteOffset; i >= 0; i--) {
                        var found = true
                        for (var j = 0; j < valLength; j++) {
                            if (read(arr, i + j) !== read(val, j)) {
                                found = false
                                break
                            }
                        }
                        if (found) return i
                    }
                }

                return -1
            }

            Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1
            }

            Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
            }

            Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
            }

            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0
                var remaining = buf.length - offset
                if (!length) {
                    length = remaining
                } else {
                    length = Number(length)
                    if (length > remaining) {
                        length = remaining
                    }
                }

                // must be an even number of digits
                var strLen = string.length
                if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

                if (length > strLen / 2) {
                    length = strLen / 2
                }
                for (var i = 0; i < length; ++i) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16)
                    if (isNaN(parsed)) return i
                    buf[offset + i] = parsed
                }
                return i
            }

            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }

            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length)
            }

            function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length)
            }

            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length)
            }

            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }

            Buffer.prototype.write = function write(string, offset, length, encoding) {
                // Buffer#write(string)
                if (offset === undefined) {
                    encoding = 'utf8'
                    length = this.length
                    offset = 0
                    // Buffer#write(string, encoding)
                } else if (length === undefined && typeof offset === 'string') {
                    encoding = offset
                    length = this.length
                    offset = 0
                    // Buffer#write(string, offset[, length][, encoding])
                } else if (isFinite(offset)) {
                    offset = offset | 0
                    if (isFinite(length)) {
                        length = length | 0
                        if (encoding === undefined) encoding = 'utf8'
                    } else {
                        encoding = length
                        length = undefined
                    }
                    // legacy write(string, encoding, offset, length) - remove in v0.13
                } else {
                    throw new Error(
                        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                    )
                }

                var remaining = this.length - offset
                if (length === undefined || length > remaining) length = remaining

                if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                    throw new RangeError('Attempt to write outside buffer bounds')
                }

                if (!encoding) encoding = 'utf8'

                var loweredCase = false
                for (; ;) {
                    switch (encoding) {
                        case 'hex':
                            return hexWrite(this, string, offset, length)

                        case 'utf8':
                        case 'utf-8':
                            return utf8Write(this, string, offset, length)

                        case 'ascii':
                            return asciiWrite(this, string, offset, length)

                        case 'latin1':
                        case 'binary':
                            return latin1Write(this, string, offset, length)

                        case 'base64':
                            // Warning: maxLength not taken into account in base64Write
                            return base64Write(this, string, offset, length)

                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return ucs2Write(this, string, offset, length)

                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }

            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }

            function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf)
                } else {
                    return base64.fromByteArray(buf.slice(start, end))
                }
            }

            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end)
                var res = []

                var i = start
                while (i < end) {
                    var firstByte = buf[i]
                    var codePoint = null
                    var bytesPerSequence = (firstByte > 0xEF) ? 4
                        : (firstByte > 0xDF) ? 3
                        : (firstByte > 0xBF) ? 2
                        : 1

                    if (i + bytesPerSequence <= end) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint

                        switch (bytesPerSequence) {
                            case 1:
                                if (firstByte < 0x80) {
                                    codePoint = firstByte
                                }
                                break
                            case 2:
                                secondByte = buf[i + 1]
                                if ((secondByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                                    if (tempCodePoint > 0x7F) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break
                            case 3:
                                secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break
                            case 4:
                                secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                fourthByte = buf[i + 3]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                        codePoint = tempCodePoint
                                    }
                                }
                        }
                    }

                    if (codePoint === null) {
                        // we did not generate a valid codePoint so insert a
                        // replacement char (U+FFFD) and advance only 1 byte
                        codePoint = 0xFFFD
                        bytesPerSequence = 1
                    } else if (codePoint > 0xFFFF) {
                        // encode to utf16 (surrogate pair dance)
                        codePoint -= 0x10000
                        res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                        codePoint = 0xDC00 | codePoint & 0x3FF
                    }

                    res.push(codePoint)
                    i += bytesPerSequence
                }

                return decodeCodePointsArray(res)
            }

            // Based on http://stackoverflow.com/a/22747272/680742, the browser with
            // the lowest limit is Chrome, with 0x10000 args.
            // We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000

            function decodeCodePointsArray(codePoints) {
                var len = codePoints.length
                if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
                }

                // Decode in chunks to avoid "call stack size exceeded".
                var res = ''
                var i = 0
                while (i < len) {
                    res += String.fromCharCode.apply(
                        String,
                        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                    )
                }
                return res
            }

            function asciiSlice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i] & 0x7F)
                }
                return ret
            }

            function latin1Slice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i])
                }
                return ret
            }

            function hexSlice(buf, start, end) {
                var len = buf.length

                if (!start || start < 0) start = 0
                if (!end || end < 0 || end > len) end = len

                var out = ''
                for (var i = start; i < end; ++i) {
                    out += toHex(buf[i])
                }
                return out
            }

            function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end)
                var res = ''
                for (var i = 0; i < bytes.length; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
                }
                return res
            }

            Buffer.prototype.slice = function slice(start, end) {
                var len = this.length
                start = ~~start
                end = end === undefined ? len : ~~end

                if (start < 0) {
                    start += len
                    if (start < 0) start = 0
                } else if (start > len) {
                    start = len
                }

                if (end < 0) {
                    end += len
                    if (end < 0) end = 0
                } else if (end > len) {
                    end = len
                }

                if (end < start) end = start

                var newBuf
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    newBuf = this.subarray(start, end)
                    newBuf.__proto__ = Buffer.prototype
                } else {
                    var sliceLen = end - start
                    newBuf = new Buffer(sliceLen, undefined)
                    for (var i = 0; i < sliceLen; ++i) {
                        newBuf[i] = this[i + start]
                    }
                }

                return newBuf
            }

            /*
             * Need to make sure that buffer isn't trying to write out of bounds.
             */
            function checkOffset(offset, ext, length) {
                if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
                if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }

            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }

                return val
            }

            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    checkOffset(offset, byteLength, this.length)
                }

                var val = this[offset + --byteLength]
                var mul = 1
                while (byteLength > 0 && (mul *= 0x100)) {
                    val += this[offset + --byteLength] * mul
                }

                return val
            }

            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length)
                return this[offset]
            }

            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                return this[offset] | (this[offset + 1] << 8)
            }

            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                return (this[offset] << 8) | this[offset + 1]
            }

            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)

                return ((this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16)) +
                    (this[offset + 3] * 0x1000000)
            }

            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (this[offset] * 0x1000000) +
                    ((this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    this[offset + 3])
            }

            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }
                mul *= 0x80

                if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                return val
            }

            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var i = byteLength
                var mul = 1
                var val = this[offset + --i]
                while (i > 0 && (mul *= 0x100)) {
                    val += this[offset + --i] * mul
                }
                mul *= 0x80

                if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                return val
            }

            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length)
                if (!(this[offset] & 0x80)) return (this[offset])
                return ((0xff - this[offset] + 1) * -1)
            }

            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset] | (this[offset + 1] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }

            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset + 1] | (this[offset] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }

            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16) |
                    (this[offset + 3] << 24)
            }

            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (this[offset] << 24) |
                    (this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    (this[offset + 3])
            }

            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, true, 23, 4)
            }

            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, false, 23, 4)
            }

            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, true, 52, 8)
            }

            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, false, 52, 8)
            }

            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
                if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
                if (offset + ext > buf.length) throw new RangeError('Index out of range')
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }

                var mul = 1
                var i = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }

                var i = byteLength - 1
                var mul = 1
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                this[offset] = (value & 0xff)
                return offset + 1
            }

            function objectWriteUInt16(buf, value, offset, littleEndian) {
                if (value < 0) value = 0xffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                        (littleEndian ? i : 1 - i) * 8
                }
            }

            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                } else {
                    objectWriteUInt16(this, value, offset, true)
                }
                return offset + 2
            }

            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = (value & 0xff)
                } else {
                    objectWriteUInt16(this, value, offset, false)
                }
                return offset + 2
            }

            function objectWriteUInt32(buf, value, offset, littleEndian) {
                if (value < 0) value = 0xffffffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
                }
            }

            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset + 3] = (value >>> 24)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 1] = (value >>> 8)
                    this[offset] = (value & 0xff)
                } else {
                    objectWriteUInt32(this, value, offset, true)
                }
                return offset + 4
            }

            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = (value & 0xff)
                } else {
                    objectWriteUInt32(this, value, offset, false)
                }
                return offset + 4
            }

            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)

                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }

                var i = 0
                var mul = 1
                var sub = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                        sub = 1
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)

                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }

                var i = byteLength - 1
                var mul = 1
                var sub = 0
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                        sub = 1
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }

                return offset + byteLength
            }

            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                if (value < 0) value = 0xff + value + 1
                this[offset] = (value & 0xff)
                return offset + 1
            }

            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                } else {
                    objectWriteUInt16(this, value, offset, true)
                }
                return offset + 2
            }

            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = (value & 0xff)
                } else {
                    objectWriteUInt16(this, value, offset, false)
                }
                return offset + 2
            }

            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 3] = (value >>> 24)
                } else {
                    objectWriteUInt32(this, value, offset, true)
                }
                return offset + 4
            }

            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (value < 0) value = 0xffffffff + value + 1
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = (value & 0xff)
                } else {
                    objectWriteUInt32(this, value, offset, false)
                }
                return offset + 4
            }

            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length) throw new RangeError('Index out of range')
                if (offset < 0) throw new RangeError('Index out of range')
            }

            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4)
                return offset + 4
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert)
            }

            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert)
            }

            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8)
                return offset + 8
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert)
            }

            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert)
            }

            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!start) start = 0
                if (!end && end !== 0) end = this.length
                if (targetStart >= target.length) targetStart = target.length
                if (!targetStart) targetStart = 0
                if (end > 0 && end < start) end = start

                // Copy 0 bytes; we're done
                if (end === start) return 0
                if (target.length === 0 || this.length === 0) return 0

                // Fatal error conditions
                if (targetStart < 0) {
                    throw new RangeError('targetStart out of bounds')
                }
                if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
                if (end < 0) throw new RangeError('sourceEnd out of bounds')

                // Are we oob?
                if (end > this.length) end = this.length
                if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start
                }

                var len = end - start
                var i

                if (this === target && start < targetStart && targetStart < end) {
                    // descending copy from end
                    for (i = len - 1; i >= 0; --i) {
                        target[i + targetStart] = this[i + start]
                    }
                } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                    // ascending copy from start
                    for (i = 0; i < len; ++i) {
                        target[i + targetStart] = this[i + start]
                    }
                } else {
                    Uint8Array.prototype.set.call(
                        target,
                        this.subarray(start, start + len),
                        targetStart
                    )
                }

                return len
            }

            // Usage:
            //    buffer.fill(number[, offset[, end]])
            //    buffer.fill(buffer[, offset[, end]])
            //    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill(val, start, end, encoding) {
                // Handle string cases:
                if (typeof val === 'string') {
                    if (typeof start === 'string') {
                        encoding = start
                        start = 0
                        end = this.length
                    } else if (typeof end === 'string') {
                        encoding = end
                        end = this.length
                    }
                    if (val.length === 1) {
                        var code = val.charCodeAt(0)
                        if (code < 256) {
                            val = code
                        }
                    }
                    if (encoding !== undefined && typeof encoding !== 'string') {
                        throw new TypeError('encoding must be a string')
                    }
                    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                        throw new TypeError('Unknown encoding: ' + encoding)
                    }
                } else if (typeof val === 'number') {
                    val = val & 255
                }

                // Invalid ranges are not set to a default, so can range check early.
                if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError('Out of range index')
                }

                if (end <= start) {
                    return this
                }

                start = start >>> 0
                end = end === undefined ? this.length : end >>> 0

                if (!val) val = 0

                var i
                if (typeof val === 'number') {
                    for (i = start; i < end; ++i) {
                        this[i] = val
                    }
                } else {
                    var bytes = Buffer.isBuffer(val)
                        ? val
                        : utf8ToBytes(new Buffer(val, encoding).toString())
                    var len = bytes.length
                    for (i = 0; i < end - start; ++i) {
                        this[i + start] = bytes[i % len]
                    }
                }

                return this
            }

            // HELPER FUNCTIONS
            // ================

            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

            function base64clean(str) {
                // Node strips out invalid characters like \n and \t from the string, base64-js does not
                str = stringtrim(str).replace(INVALID_BASE64_RE, '')
                // Node converts strings with length < 2 to ''
                if (str.length < 2) return ''
                // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                while (str.length % 4 !== 0) {
                    str = str + '='
                }
                return str
            }

            function stringtrim(str) {
                if (str.trim) return str.trim()
                return str.replace(/^\s+|\s+$/g, '')
            }

            function toHex(n) {
                if (n < 16) return '0' + n.toString(16)
                return n.toString(16)
            }

            function utf8ToBytes(string, units) {
                units = units || Infinity
                var codePoint
                var length = string.length
                var leadSurrogate = null
                var bytes = []

                for (var i = 0; i < length; ++i) {
                    codePoint = string.charCodeAt(i)

                    // is surrogate component
                    if (codePoint > 0xD7FF && codePoint < 0xE000) {
                        // last char was a lead
                        if (!leadSurrogate) {
                            // no lead yet
                            if (codePoint > 0xDBFF) {
                                // unexpected trail
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            } else if (i + 1 === length) {
                                // unpaired lead
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            }

                            // valid lead
                            leadSurrogate = codePoint

                            continue
                        }

                        // 2 leads in a row
                        if (codePoint < 0xDC00) {
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            leadSurrogate = codePoint
                            continue
                        }

                        // valid surrogate pair
                        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                    } else if (leadSurrogate) {
                        // valid bmp char, but last char was a lead
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                    }

                    leadSurrogate = null

                    // encode utf8
                    if (codePoint < 0x80) {
                        if ((units -= 1) < 0) break
                        bytes.push(codePoint)
                    } else if (codePoint < 0x800) {
                        if ((units -= 2) < 0) break
                        bytes.push(
                            codePoint >> 0x6 | 0xC0,
                            codePoint & 0x3F | 0x80
                        )
                    } else if (codePoint < 0x10000) {
                        if ((units -= 3) < 0) break
                        bytes.push(
                            codePoint >> 0xC | 0xE0,
                            codePoint >> 0x6 & 0x3F | 0x80,
                            codePoint & 0x3F | 0x80
                        )
                    } else if (codePoint < 0x110000) {
                        if ((units -= 4) < 0) break
                        bytes.push(
                            codePoint >> 0x12 | 0xF0,
                            codePoint >> 0xC & 0x3F | 0x80,
                            codePoint >> 0x6 & 0x3F | 0x80,
                            codePoint & 0x3F | 0x80
                        )
                    } else {
                        throw new Error('Invalid code point')
                    }
                }

                return bytes
            }

            function asciiToBytes(str) {
                var byteArray = []
                for (var i = 0; i < str.length; ++i) {
                    // Node's code seems to be doing this and not & 0x7F..
                    byteArray.push(str.charCodeAt(i) & 0xFF)
                }
                return byteArray
            }

            function utf16leToBytes(str, units) {
                var c, hi, lo
                var byteArray = []
                for (var i = 0; i < str.length; ++i) {
                    if ((units -= 2) < 0) break

                    c = str.charCodeAt(i)
                    hi = c >> 8
                    lo = c % 256
                    byteArray.push(lo)
                    byteArray.push(hi)
                }

                return byteArray
            }

            function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str))
            }

            function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                    if ((i + offset >= dst.length) || (i >= src.length)) break
                    dst[i + offset] = src[i]
                }
                return i
            }

            function isnan(val) {
                return val !== val // eslint-disable-line no-self-compare
            }

            /* WEBPACK VAR INJECTION */
        }.call(exports, (function () {
            return this;
        }())))

        /***/
    },
    /* 13 */
    /***/ function (module, exports) {

        'use strict'

        exports.byteLength = byteLength
        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray

        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i]
            revLookup[code.charCodeAt(i)] = i
        }

        revLookup['-'.charCodeAt(0)] = 62
        revLookup['_'.charCodeAt(0)] = 63

        function placeHoldersCount(b64) {
            var len = b64.length
            if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
            }

            // the number of equal signs (place holders)
            // if there are two placeholders, than the two characters before it
            // represent one byte
            // if there is only one, then the three characters before it represent 2 bytes
            // this is just a cheap hack to not do indexOf twice
            return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
        }

        function byteLength(b64) {
            // base64 is 4/3 + up to two characters of the original data
            return b64.length * 3 / 4 - placeHoldersCount(b64)
        }

        function toByteArray(b64) {
            var i, j, l, tmp, placeHolders, arr
            var len = b64.length
            placeHolders = placeHoldersCount(b64)

            arr = new Arr(len * 3 / 4 - placeHolders)

            // if there are placeholders, only get up to the last complete 4 chars
            l = placeHolders > 0 ? len - 4 : len

            var L = 0

            for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
                arr[L++] = (tmp >> 16) & 0xFF
                arr[L++] = (tmp >> 8) & 0xFF
                arr[L++] = tmp & 0xFF
            }

            if (placeHolders === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
                arr[L++] = tmp & 0xFF
            } else if (placeHolders === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
                arr[L++] = (tmp >> 8) & 0xFF
                arr[L++] = tmp & 0xFF
            }

            return arr
        }

        function tripletToBase64(num) {
            return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
        }

        function encodeChunk(uint8, start, end) {
            var tmp
            var output = []
            for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                output.push(tripletToBase64(tmp))
            }
            return output.join('')
        }

        function fromByteArray(uint8) {
            var tmp
            var len = uint8.length
            var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
            var output = ''
            var parts = []
            var maxChunkLength = 16383 // must be multiple of 3

            // go through the array every three bytes, we'll deal with trailing stuff later
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
            }

            // pad the end with zeros, but make sure to not forget the extra bytes
            if (extraBytes === 1) {
                tmp = uint8[len - 1]
                output += lookup[tmp >> 2]
                output += lookup[(tmp << 4) & 0x3F]
                output += '=='
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
                output += lookup[tmp >> 10]
                output += lookup[(tmp >> 4) & 0x3F]
                output += lookup[(tmp << 2) & 0x3F]
                output += '='
            }

            parts.push(output)

            return parts.join('')
        }


        /***/
    },
    /* 14 */
    /***/ function (module, exports) {

        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var nBits = -7
            var i = isLE ? (nBytes - 1) : 0
            var d = isLE ? -1 : 1
            var s = buffer[offset + i]

            i += d

            e = s & ((1 << (-nBits)) - 1)
            s >>= (-nBits)
            nBits += eLen
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
            }

            m = e & ((1 << (-nBits)) - 1)
            e >>= (-nBits)
            nBits += mLen
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
            }

            if (e === 0) {
                e = 1 - eBias
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
            } else {
                m = m + Math.pow(2, mLen)
                e = e - eBias
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }

        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
            var i = isLE ? 0 : (nBytes - 1)
            var d = isLE ? 1 : -1
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

            value = Math.abs(value)

            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0
                e = eMax
            } else {
                e = Math.floor(Math.log(value) / Math.LN2)
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--
                    c *= 2
                }
                if (e + eBias >= 1) {
                    value += rt / c
                } else {
                    value += rt * Math.pow(2, 1 - eBias)
                }
                if (value * c >= 2) {
                    e++
                    c /= 2
                }

                if (e + eBias >= eMax) {
                    m = 0
                    e = eMax
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen)
                    e = e + eBias
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                    e = 0
                }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {
            }

            e = (e << mLen) | m
            eLen += mLen
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {
            }

            buffer[offset + i - d] |= s * 128
        }


        /***/
    },
    /* 15 */
    /***/ function (module, exports) {

        var toString = {}.toString;

        module.exports = Array.isArray || function (arr) {
                return toString.call(arr) == '[object Array]';
            };


        /***/
    },
    /* 16 */
    /***/ function (module, exports) {

        /**
         * Bit twiddling hacks for JavaScript.
         *
         * Author: Mikola Lysenko
         *
         * Ported from Stanford bit twiddling hack library:
         *    http://graphics.stanford.edu/~seander/bithacks.html
         */

        "use strict";
        "use restrict";

        //Number of bits in an integer
        var INT_BITS = 32;

        //Constants
        exports.INT_BITS = INT_BITS;
        exports.INT_MAX = 0x7fffffff;
        exports.INT_MIN = -1 << (INT_BITS - 1);

        //Returns -1, 0, +1 depending on sign of x
        exports.sign = function (v) {
            return (v > 0) - (v < 0);
        }

        //Computes absolute value of integer
        exports.abs = function (v) {
            var mask = v >> (INT_BITS - 1);
            return (v ^ mask) - mask;
        }

        //Computes minimum of integers x and y
        exports.min = function (x, y) {
            return y ^ ((x ^ y) & -(x < y));
        }

        //Computes maximum of integers x and y
        exports.max = function (x, y) {
            return x ^ ((x ^ y) & -(x < y));
        }

        //Checks if a number is a power of two
        exports.isPow2 = function (v) {
            return !(v & (v - 1)) && (!!v);
        }

        //Computes log base 2 of v
        exports.log2 = function (v) {
            var r, shift;
            r = (v > 0xFFFF) << 4;
            v >>>= r;
            shift = (v > 0xFF  ) << 3;
            v >>>= shift;
            r |= shift;
            shift = (v > 0xF   ) << 2;
            v >>>= shift;
            r |= shift;
            shift = (v > 0x3   ) << 1;
            v >>>= shift;
            r |= shift;
            return r | (v >> 1);
        }

        //Computes log base 10 of v
        exports.log10 = function (v) {
            return (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
                (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
                    (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
        }

        //Counts number of bits
        exports.popCount = function (v) {
            v = v - ((v >>> 1) & 0x55555555);
            v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
            return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
        }

        //Counts number of trailing zeros
        function countTrailingZeros(v) {
            var c = 32;
            v &= -v;
            if (v) c--;
            if (v & 0x0000FFFF) c -= 16;
            if (v & 0x00FF00FF) c -= 8;
            if (v & 0x0F0F0F0F) c -= 4;
            if (v & 0x33333333) c -= 2;
            if (v & 0x55555555) c -= 1;
            return c;
        }

        exports.countTrailingZeros = countTrailingZeros;

        //Rounds to next power of 2
        exports.nextPow2 = function (v) {
            v += v === 0;
            --v;
            v |= v >>> 1;
            v |= v >>> 2;
            v |= v >>> 4;
            v |= v >>> 8;
            v |= v >>> 16;
            return v + 1;
        }

        //Rounds down to previous power of 2
        exports.prevPow2 = function (v) {
            v |= v >>> 1;
            v |= v >>> 2;
            v |= v >>> 4;
            v |= v >>> 8;
            v |= v >>> 16;
            return v - (v >>> 1);
        }

        //Computes parity of word
        exports.parity = function (v) {
            v ^= v >>> 16;
            v ^= v >>> 8;
            v ^= v >>> 4;
            v &= 0xf;
            return (0x6996 >>> v) & 1;
        }

        var REVERSE_TABLE = new Array(256);

        (function (tab) {
            for (var i = 0; i < 256; ++i) {
                var v = i, r = i, s = 7;
                for (v >>>= 1; v; v >>>= 1) {
                    r <<= 1;
                    r |= v & 1;
                    --s;
                }
                tab[i] = (r << s) & 0xff;
            }
        })(REVERSE_TABLE);

        //Reverse bits in a 32 bit word
        exports.reverse = function (v) {
            return (REVERSE_TABLE[v & 0xff] << 24) |
                (REVERSE_TABLE[(v >>> 8) & 0xff] << 16) |
                (REVERSE_TABLE[(v >>> 16) & 0xff] << 8) |
                REVERSE_TABLE[(v >>> 24) & 0xff];
        }

        //Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
        exports.interleave2 = function (x, y) {
            x &= 0xFFFF;
            x = (x | (x << 8)) & 0x00FF00FF;
            x = (x | (x << 4)) & 0x0F0F0F0F;
            x = (x | (x << 2)) & 0x33333333;
            x = (x | (x << 1)) & 0x55555555;

            y &= 0xFFFF;
            y = (y | (y << 8)) & 0x00FF00FF;
            y = (y | (y << 4)) & 0x0F0F0F0F;
            y = (y | (y << 2)) & 0x33333333;
            y = (y | (y << 1)) & 0x55555555;

            return x | (y << 1);
        }

        //Extracts the nth interleaved component
        exports.deinterleave2 = function (v, n) {
            v = (v >>> n) & 0x55555555;
            v = (v | (v >>> 1)) & 0x33333333;
            v = (v | (v >>> 2)) & 0x0F0F0F0F;
            v = (v | (v >>> 4)) & 0x00FF00FF;
            v = (v | (v >>> 16)) & 0x000FFFF;
            return (v << 16) >> 16;
        }


        //Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
        exports.interleave3 = function (x, y, z) {
            x &= 0x3FF;
            x = (x | (x << 16)) & 4278190335;
            x = (x | (x << 8)) & 251719695;
            x = (x | (x << 4)) & 3272356035;
            x = (x | (x << 2)) & 1227133513;

            y &= 0x3FF;
            y = (y | (y << 16)) & 4278190335;
            y = (y | (y << 8)) & 251719695;
            y = (y | (y << 4)) & 3272356035;
            y = (y | (y << 2)) & 1227133513;
            x |= (y << 1);

            z &= 0x3FF;
            z = (z | (z << 16)) & 4278190335;
            z = (z | (z << 8)) & 251719695;
            z = (z | (z << 4)) & 3272356035;
            z = (z | (z << 2)) & 1227133513;

            return x | (z << 2);
        }

        //Extracts nth interleaved component of a 3-tuple
        exports.deinterleave3 = function (v, n) {
            v = (v >>> n) & 1227133513;
            v = (v | (v >>> 2)) & 3272356035;
            v = (v | (v >>> 4)) & 251719695;
            v = (v | (v >>> 8)) & 4278190335;
            v = (v | (v >>> 16)) & 0x3FF;
            return (v << 22) >> 22;
        }

        //Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
        exports.nextCombination = function (v) {
            var t = v | (v - 1);
            return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
        }


        /***/
    },
    /* 17 */
    /***/ function (module, exports) {

        "use strict"

        function dupe_array(count, value, i) {
            var c = count[i] | 0
            if (c <= 0) {
                return []
            }
            var result = new Array(c), j
            if (i === count.length - 1) {
                for (j = 0; j < c; ++j) {
                    result[j] = value
                }
            } else {
                for (j = 0; j < c; ++j) {
                    result[j] = dupe_array(count, value, i + 1)
                }
            }
            return result
        }

        function dupe_number(count, value) {
            var result, i
            result = new Array(count)
            for (i = 0; i < count; ++i) {
                result[i] = value
            }
            return result
        }

        function dupe(count, value) {
            if (typeof value === "undefined") {
                value = 0
            }
            switch (typeof count) {
                case "number":
                    if (count > 0) {
                        return dupe_number(count | 0, value)
                    }
                    break
                case "object":
                    if (typeof (count.length) === "number") {
                        return dupe_array(count, value, 0)
                    }
                    break
            }
            return []
        }

        module.exports = dupe

        /***/
    },
    /* 18 */
    /***/ function (module, exports) {

        //
        //  barnes-hut.js
        //
        //  implementation of the barnes-hut quadtree algorithm for n-body repulsion
        //  http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html
        //
        //  Created by Christian Swinehart on 2011-01-14.
        //  Copyright (c) 2011 Samizdat Drafting Co. All rights reserved.
        //
        //

        var Cell = function (origin, size) {
            this.nw = undefined
            this.ne = undefined
            this.sw = undefined
            this.se = undefined
            this.origin = origin
            this.size = size
            this.p = undefined
            this.mass = 0
        }


        var BarnesHutTree = function () {
            var _branches = []
            var _branchCtr = 0
            var _root = null
            var _theta = .5

            var that = {
                init: function (topleft, bottomright, theta) {
                    _theta = theta

                    // Reset the pointer in the Cell allocator
                    _branchCtr = 0

                    // create a fresh root node for these spatial bounds
                    _root = that._newBranch(topleft, bottomright.subtract(topleft))
                },

                initWithData: function (data, theta, N) {
                    // TODO: keep the data in place?
                    // compute top left and top right based on data and call init
                    var topleft = new Point(0, 0)
                    var bottomright = new Point(0, 0)
                    for (var i = 0; i < N; i++) {
                        var x = data.get(i, 0)
                        var y = data.get(i, 1)
                        if (x < topleft.x) topleft.x = x
                        if (y < topleft.y) topleft.y = y
                        if (x > bottomright.x) bottomright.x = x
                        if (y > bottomright.y) bottomright.y = y
                    }
                    that.init(topleft, bottomright, theta);
                    // then insert all the points
                    for (var i = 0; i < N; i++) {
                        that.insert(data.get(i, 0), data.get(i, 1));
                    }
                },
                isCorrect: function () {

                    var queue = [_root]


                    var recurse = function (pnode, node) {
                        if (node === undefined) {
                            return true;
                        }

                        if (!(pnode === null || _contains(pnode, node))) {
                            console.error(pnode, node)
                            return false;
                        }

                        // Just a point, or all children also are correct
                        return (!('origin' in node) ||
                        (recurse(node, node.nw)
                            && recurse(node, node.ne)
                            && recurse(node, node.sw)
                            && recurse(node, node.se)
                        ))
                    }

                    return recurse(null, _root)
                },
                insert: function (x, y) {
                    // add a particle to the tree, starting at the current _root and working down
                    var node = _root
                    var queue = [new Point(x, y)]
                    var point, p_quad, mult1, mult2, branch_size, branch_origin, oldPoint

                    while (queue.length) {
                        point = queue.shift()
                        p_quad = that._whichQuad(point, node)

                        // Increment total mass (count) and update center
                        node.mass += 1.
                        mult1 = (node.mass - 1) / node.mass
                        mult2 = 1 / node.mass
                        if (node.p) {
                            node.p = node.p.multiply(mult1).add(point.multiply(mult2))
                        } else {
                            node.p = point
                        }

                        if (node[p_quad] === undefined) {
                            // slot is empty, just drop this node in and update the mass/c.o.m.
                            node[p_quad] = point
                        } else if ('origin' in node[p_quad]) {
                            // slot contains a branch node,
                            // keep iterating with the branch as our new root
                            node = node[p_quad]

                            // put point back
                            queue.unshift(point)
                        } else {
                            // slot contains a point, create a new branch (subdivide)
                            // and recurse with both points in the queue now
                            branch_size = node.size.divide(2)
                            branch_origin = new Point(node.origin)
                            if (p_quad[0] == 's') branch_origin.y += branch_size.y
                            if (p_quad[1] == 'e') branch_origin.x += branch_size.x

                            // replace the previously point-occupied quad with a new internal branch node
                            oldPoint = node[p_quad]
                            node[p_quad] = that._newBranch(branch_origin, branch_size)

                            // Switch down into the new branch
                            node = node[p_quad]

                            //if (oldParticle.p.x===particle.p.x && oldParticle.p.y===particle.p.y){
                            //  // prevent infinite bisection in the case where two particles
                            //  // have identical coordinates by jostling one of them slightly
                            //  var x_spread = branch_size.x*.08
                            //  var y_spread = branch_size.y*.08
                            //  oldParticle.p.x = Math.min(branch_origin.x+branch_size.x,
                            //                             Math.max(branch_origin.x,
                            //                                      oldParticle.p.x - x_spread/2 +
                            //                                      Math.random()*x_spread))
                            //  oldParticle.p.y = Math.min(branch_origin.y+branch_size.y,
                            //                             Math.max(branch_origin.y,
                            //                                      oldParticle.p.y - y_spread/2 +
                            //                                      Math.random()*y_spread))
                            //}

                            // keep iterating but now having to place both the current particle and the
                            // one we just replaced with the branch node
                            queue.push(oldPoint)
                            queue.unshift(point)
                        }

                    }

                },

                computeForces: function (x, y) {
                    var xForce = 0.
                    var yForce = 0.

                    var Z = 0.  // Z
                    var count = 0

                    var dx, dy, distSq, dist, aff, force, rcell, node

                    var queue = [_root]
                    while (queue.length) {
                        count++
                        node = queue.shift()
                        if (node === undefined) {
                            continue
                        } else if (node instanceof Point) {
                            // this is a point leafnode, so just apply the force directly
                            dx = x - node.x
                            dy = y - node.y
                            distSq = dx * dx + dy * dy
                            aff = 1. / (1. + distSq)
                            force = -aff * aff  // -qu_ij^2 = -(q_ij * Z)^2
                            if (distSq < 1e-5) continue
                            // Accumulate force and Z
                            xForce += force * dx
                            yForce += force * dy
                            Z += aff
                        } else {
                            // it's a branch node so decide if it's cluster-y and distant enough
                            // to summarize as a single point. if it's too complex, open it and deal
                            // with its quadrants in turn
                            dx = x - node.p.x
                            dy = y - node.p.y
                            distSq = dx * dx + dy * dy
                            dist = Math.sqrt(distSq)
                            rcell = node.size.x > node.size.y ? node.size.x : node.size.y
                            if (rcell / dist > _theta) { // i.e., s/d > Θ
                                // open the quad and recurse
                                queue.push(node.ne)
                                queue.push(node.nw)
                                queue.push(node.se)
                                queue.push(node.sw)
                            } else {
                                // treat the quad as a single body
                                aff = 1.0 / (1.0 + distSq)
                                force = -node.mass * aff * aff  // - N_cell * (q_{i,cell} * Z)^2
                                //var direction = (d.magnitude()>0) ? d : Point.random(1e-5)
                                // Accumulate force and Z
                                xForce += force * dx
                                yForce += force * dy
                                Z += node.mass * aff
                            }
                        }
                    }

                    // Return accumulated forces on the particle
                    return {
                        x: xForce,
                        y: yForce,
                        Z: Z,
                    }
                },

                _whichQuad: function (p, node) {
                    // sort the point into one of the quadrants of this node
                    if (p.exploded()) return null
                    var particle_p = p.subtract(node.origin)
                    var halfsize = node.size.divide(2)
                    if (particle_p.y < halfsize.y) {
                        if (particle_p.x < halfsize.x) return 'nw'
                        else return 'ne'
                    } else {
                        if (particle_p.x < halfsize.x) return 'sw'
                        else return 'se'
                    }
                },

                _newBranch: function (origin, size) {
                    // to prevent a gc horrorshow, recycle the tree nodes between iterations
                    if (_branches[_branchCtr]) {
                        // Use old node object if one exists
                        var branch = _branches[_branchCtr]
                        branch.ne = branch.nw = branch.se = branch.sw = undefined
                        branch.origin = origin
                        branch.size = size
                        branch.mass = 0
                        branch.p = undefined
                    } else {
                        // Create new branch object
                        branch = new Cell(origin, size)
                        _branches[_branchCtr] = branch
                    }

                    _branchCtr++
                    return branch
                }
            }

            return that
        }

        var _contains = function (node, child) {
            var bottomright = node.origin.add(node.size)
            return (
                child.p.x >= node.origin.x - 1e-5
                && child.p.y >= node.origin.y - 1e-5
                && child.p.x <= bottomright.x + 1e-5
                && child.p.y <= bottomright.y + 1e-5
            )
        }

        var Point = function (x, y) {
            if (x && x.hasOwnProperty('y')) {
                y = x.y;
                x = x.x;
            }
            this.x = x;
            this.y = y;
        }

        Point.random = function (radius) {
            console.error('random??')
            radius = (radius !== undefined) ? radius : 5
            return new Point(2 * radius * (Math.random() - 0.5), 2 * radius * (Math.random() - 0.5));
        }

        Point.prototype = {
            exploded: function () {
                return ( isNaN(this.x) || isNaN(this.y) )
            },
            add: function (v2) {
                return new Point(this.x + v2.x, this.y + v2.y);
            },
            subtract: function (v2) {
                return new Point(this.x - v2.x, this.y - v2.y);
            },
            multiply: function (n) {
                return new Point(this.x * n, this.y * n);
            },
            divide: function (n) {
                return new Point(this.x / n, this.y / n);
            },
            magnitude: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            magnitudeSquared: function () {
                return this.x * this.x + this.y * this.y;
            },
            normal: function () {
                return new Point(-this.y, this.x);
            },
            normalize: function () {
                return this.divide(this.magnitude());
            }
        }

        module.exports = {
            BarnesHutTree: BarnesHutTree,
            Point: Point,
        }


        /***/
    },
    /* 19 */
    /***/ function (module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*╔═════════════════════════════════════════════════════════════════════════════════════════════════════════╗
         *║                                                                                                         ║
         *║      vptree.js v0.2.3                                                                                   ║
         *║      https://github.com/fpirsch/vptree.js                                                               ║
         *║                                                                                                         ║
         *║      A javascript implementation of the Vantage-Point Tree algorithm                                    ║
         *║      ISC license (http://opensource.org/licenses/ISC). François Pirsch. 2013.                           ║
         *║                                                                                                         ║
         *║      Date: 2015-12-24T11:39Z                                                                            ║
         *║                                                                                                         ║
         *╚═════════════════════════════════════════════════════════════════════════════════════════════════════════╝
         */

        /* jshint node: true */
        /* global define */

        //https://github.com/umdjs/umd/blob/master/commonjsStrictGlobal.js
        (function (root, factory) {
            if (true) {
                // AMD. Register as an anonymous module.
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (exports) {
                    factory(root.VPTreeFactory = exports);
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof exports === 'object') {
                // CommonJS
                factory(exports);
            } else {
                // Browser globals
                factory(root.VPTreeFactory = {});
            }
        }(this, function (exports) {
            "use strict";
            /* global VPTree, exports */

            /*───────────────────────────────────────────────────────────────────────────┐
             │   Selection/partition algorithm                                           │
             └───────────────────────────────────────────────────────────────────────────*/

            function partition(list, left, right, pivotIndex, comp) {
                var pivotValue = list[pivotIndex];
                var swap = list[pivotIndex];  // Move pivot to end
                list[pivotIndex] = list[right];
                list[right] = swap;
                var storeIndex = left;
                for (var i = left; i < right; i++) {
                    if (comp(list[i], pivotValue)) {
                        swap = list[storeIndex];
                        list[storeIndex] = list[i];
                        list[i] = swap;
                        storeIndex++;
                    }
                }
                swap = list[right];       // Move pivot to its final place
                list[right] = list[storeIndex];
                list[storeIndex] = swap;
                return storeIndex;
            }

            // Pivot selection : computes the median of elements a, b and c of the list,
            // according to comparator comp.
            function medianOf3(list, a, b, c, comp) {
                var A = list[a], B = list[b], C = list[c];
                return comp(A, B) ?
                    comp(B, C) ? b : comp(A, C) ? c : a :
                    comp(A, C) ? a : comp(B, C) ? c : b;
            }

            /**
             * Quickselect : Finds the nth smallest number in a list according to comparator comp.
             * All elements smaller than the nth element are moved to its left (in no particular order),
             * and all elements greater thant the nth are moved to its right.
             *
             * The funny mix of 0-based and 1-based indexes comes from the C++
             * Standard Library function nth_element.
             *
             * @param {Array} list - the list to partition
             * @param {int} left - index in the list of the first element of the sublist.
             * @param {int} right - index in the list of the last element of the sublist (inclusive)
             * @param {int} nth - index, in the range [1, sublist.length] of the element to find.
             * @param {function} comp - a comparator, i.e. a boolean function accepting two parameters a and b,
             *        and returning true if a < b and false if a >= b.
             *
             * See http://en.wikipedia.org/wiki/Quickselect
             * And /include/bits/stl_algo.h in the GCC Standard Library ( http://gcc.gnu.org/libstdc++/ )
             */
            function nth_element(list, left, nth, right, comp) {
                if (nth <= 0 || nth > (right - left + 1)) throw new Error("VPTree.nth_element: nth must be in range [1, right-left+1] (nth=" + nth + ")");
                var pivotIndex, pivotNewIndex, pivotDist;
                for (; ;) {
                    // select pivotIndex between left and right
                    pivotIndex = medianOf3(list, left, right, (left + right) >> 1, comp);
                    pivotNewIndex = partition(list, left, right, pivotIndex, comp);
                    pivotDist = pivotNewIndex - left + 1;
                    if (pivotDist === nth) {
                        return list[pivotNewIndex];
                    }
                    else if (nth < pivotDist) {
                        right = pivotNewIndex - 1;
                    }
                    else {
                        nth -= pivotDist;
                        left = pivotNewIndex + 1;
                    }
                }
            }


            /**
             * Wrapper around nth_element with a 0-based index.
             */
            function select(list, k, comp) {
                if (k < 0 || k >= list.length) {
                    throw new Error("VPTree.select: k must be in range [0, list.length-1] (k=" + k + ")");
                }
                return nth_element(list, 0, k + 1, list.length - 1, comp);
            }


            /*───────────────────────────────────────────────────────────────────────────┐
             │   vp-tree creation                                                        │
             └───────────────────────────────────────────────────────────────────────────*/
            /** Selects a vantage point in a set.
             *  We trivially pick one at random.
             *  TODO this could be improved by random sampling to maximize spread.
             */
            function selectVPIndex(list) {
                return Math.floor(Math.random() * list.length);
            }

            var distanceComparator = function (a, b) {
                return a.dist < b.dist;
            };

            /**
             * Builds and returns a vp-tree from the list S.
             * @param {Array} S array of objects to structure into a vp-tree.
             * @param {function} distance a function returning the distance between 2 ojects from the list S.
             * @param {number} nb (maximum) bucket size. 0 or undefined = no buckets used.
             * @return {object} vp-tree.
             */
            function buildVPTree(S, distance, nb) {
                var list = [];
                for (var i = 0, n = S.length; i < n; i++) {
                    list[i] = {
                        i: i
                        //hist: []    // unused (yet)
                    };
                }

                var tree = recurseVPTree(S, list, distance, nb);
                return new VPTree(S, distance, tree);
            }

            function recurseVPTree(S, list, distance, nb) {
                if (list.length === 0) return null;
                var i;

                // Is this a leaf node ?
                var listLength = list.length;
                if (nb > 0 && listLength <= nb) {
                    var bucket = [];
                    for (i = 0; i < listLength; i++) {
                        bucket[i] = list[i].i;
                    }
                    return bucket;
                }

                // Non-leaf node.
                // Constructs a node with the selected vantage point extracted from the set.
                var vpIndex = selectVPIndex(list),
                    node = list[vpIndex];
                list.splice(vpIndex, 1);
                listLength--;
                // We can't use node.dist yet, so don't show it in the vp-tree output.
                node = {i: node.i};
                if (listLength === 0) return node;

                // Adds to each item its distance to the vantage point.
                // This ensures each distance is computed only once.
                var vp = S[node.i],
                    dmin = Infinity,
                    dmax = 0,
                    item, dist, n;
                for (i = 0, n = listLength; i < n; i++) {
                    item = list[i];
                    dist = distance(vp, S[item.i]);
                    item.dist = dist;
                    //item.hist.push(dist); // unused (yet)
                    if (dmin > dist) dmin = dist;
                    if (dmax < dist) dmax = dist;
                }
                node.m = dmin;
                node.M = dmax;

                // Partitions the set around the median distance.
                var medianIndex = listLength >> 1,
                    median = select(list, medianIndex, distanceComparator);

                // Recursively builds vp-trees with the 2 resulting subsets.
                var leftItems = list.splice(0, medianIndex),
                    rightItems = list;
                node.μ = median.dist;
                node.L = recurseVPTree(S, leftItems, distance, nb);
                node.R = recurseVPTree(S, rightItems, distance, nb);
                return node;
            }


            /** Stringifies a vp-tree data structure.
             *  JSON without the null nodes and the quotes around object keys, to save space.
             */
            function stringify(root) {
                var stack = [root || this.tree], s = '';
                while (stack.length) {
                    var node = stack.pop();

                    // Happens if the bucket size is greater thant the dataset.
                    if (node.length) return '[' + node.join(',') + ']';

                    s += '{i:' + node.i;
                    if (node.hasOwnProperty('m')) {
                        s += ',m:' + node.m + ',M:' + node.M + ',μ:' + node.μ;
                    }
                    if (node.hasOwnProperty('b')) {
                        s += ',b:[' + node.b + ']';
                    }
                    if (node.hasOwnProperty('L')) {
                        var L = node.L;
                        if (L) {
                            s += ',L:';
                            if (L.length) s += '[' + L + ']';
                            else s += stringify(L);
                        }
                    }
                    if (node.hasOwnProperty('R')) {
                        var R = node.R;
                        if (R) {
                            s += ',R:';
                            if (R.length) s += '[' + R + ']';
                            else s += stringify(R);
                        }
                    }
                    s += '}';
                }
                return s;
            }

            /*───────────────────────────────────────────────────────────────────────────┐
             │   Build Public API                                                        │
             └───────────────────────────────────────────────────────────────────────────*/

            exports.select = select;
            exports.build = buildVPTree;


            /*───────────────────────────────────────────────────────────────────────────┐
             │   Priority Queue, used to store search results.                           │
             └───────────────────────────────────────────────────────────────────────────*/

            /**
             * @constructor
             * @class PriorityQueue manages a queue of elements with priorities.
             *
             * @param {number} size maximum size of the queue (default = 5). Only lowest priority items will be retained.
             */
            function PriorityQueue(size) {
                size = size || 5;
                var contents = [];

                function binaryIndexOf(priority) {
                    var minIndex = 0,
                        maxIndex = contents.length - 1,
                        currentIndex,
                        currentElement;

                    while (minIndex <= maxIndex) {
                        currentIndex = (minIndex + maxIndex) >> 1;
                        currentElement = contents[currentIndex].priority;

                        if (currentElement < priority) {
                            minIndex = currentIndex + 1;
                        }
                        else if (currentElement > priority) {
                            maxIndex = currentIndex - 1;
                        }
                        else {
                            return currentIndex;
                        }
                    }

                    return -1 - minIndex;
                }

                var api = {
                    // This breaks IE8 compatibility. Who cares ?
                    get length() {
                        return contents.length;
                    },

                    insert: function (data, priority) {
                        var index = binaryIndexOf(priority);
                        if (index < 0) index = -1 - index;
                        if (index < size) {
                            contents.splice(index, 0, {data: data, priority: priority});
                            if (contents.length > size) {
                                contents.length--;
                            }
                        }
                        return contents.length === size ? contents[contents.length - 1].priority : undefined;
                    },

                    list: function () {
                        return contents.map(function (item) {
                            return {i: item.data, d: item.priority};
                        });
                    }
                };

                return api;
            }


            /*───────────────────────────────────────────────────────────────────────────┐
             │   vp-tree search                                                          │
             └───────────────────────────────────────────────────────────────────────────*/

            /**
             * @param {object} q - query : any object the distance function can be applied to.
             * @param {number} [n=1] - number of nearest neighbors to find
             * @param {number} [τ=∞] - maximum distance from element q
             *
             * @return {object[]} list of search results, ordered by increasing distance to the query object.
             *                    Each result has a property i which is the index of the element in S, and d which
             *                    is its distance to the query object.
             */
            function searchVPTree(q, n, τ) {
                τ = τ || Infinity;
                var W = new PriorityQueue(n || 1),
                    S = this.S,
                    distance = this.distance,
                    comparisons = 0;

                function doSearch(node) {
                    if (node === null) return;

                    // Leaf node : test each element in this node's bucket.
                    if (node.length) {
                        for (var i = 0, n = node.length; i < n; i++) {
                            comparisons++;
                            var elementID = node[i],
                                element = S[elementID],
                                elementDist = distance(q, element);
                            if (elementDist < τ) {
                                τ = W.insert(elementID, elementDist) || τ;
                            }
                        }
                        return;
                    }

                    // Non-leaf node
                    var id = node.i,
                        p = S[id],
                        dist = distance(q, p);

                    comparisons++;

                    // This vantage-point is close enough to q.
                    if (dist < τ) {
                        τ = W.insert(id, dist) || τ;
                    }

                    // The order of exploration is determined by comparison with μ.
                    // The sooner we find elements close to q, the smaller τ and the more nodes we skip.
                    // P. Yianilos uses the middle of left/right bounds instead of μ.
                    // We search L if dist is in (m - τ, μ + τ), and R if dist is in (μ - τ, M + τ)
                    var μ = node.μ, L = node.L, R = node.R;
                    if (μ === undefined) return;
                    if (dist < μ) {
                        if (L && node.m - τ < dist) doSearch(L);
                        if (R && μ - τ < dist) doSearch(R);
                    }
                    else {
                        if (R && dist < node.M + τ) doSearch(R);
                        if (L && dist < μ + τ) doSearch(L);
                    }
                }

                doSearch(this.tree);
                this.comparisons = comparisons;
                return W.list();
            }


            /*───────────────────────────────────────────────────────────────────────────┐
             │   vp-tree constructor                                                     │
             └───────────────────────────────────────────────────────────────────────────*/

            /**
             * @constructor
             * @class VPTree manages a vp-tree.
             *
             * @param {Array} S the initial set of elements
             * @param {Function} distance the distance function
             * @param {Object} the vp-tree structure
             */
            function VPTree(S, distance, tree) {
                this.S = S;
                this.distance = distance;
                this.tree = tree;

                this.search = searchVPTree;
                this.comparisons = 0;
                this.stringify = stringify;
            }


            exports.load = function (S, distance, tree) {
                return new VPTree(S, distance, tree);
            };
        }));

        /***/
    }
    /******/]);